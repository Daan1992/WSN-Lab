###############################################################################
#
# IAR C/C++ Compiler V6.20.1.931/W32 for MSP430           26/Jun/2015  10:51:10
# Copyright 1996-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.20
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  
#        C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\target\cc2480\hal_board.c
#    Command line  =  
#        -f "C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\ZASA\IAR\..\Source\ZASA.cfg" (-DZACCEL_BUF_LEN=128
#        -DHOST_MT_BAUD=9600 -DHOST_MT_RX_OLD=1
#        "-DHOST_MT_RX_FULL=(ZACCEL_BUF_LEN-1)" -DZACCEL_NV_CHANLIST=0x00008000
#        -DZACCEL_NV_PANID=0x0DED)
#        "C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\target\cc2480\hal_board.c" -D ROUTER -D APP_BLINK_LEDS -lC
#        "C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\ZASA\IAR\Router\List\" --remarks --diag_suppress Pe068 -o
#        "C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\ZASA\IAR\Router\Obj\" --debug -D__MSP430F2274__
#        --warnings_are_errors -e --double=32 --clib -I
#        "C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\ZASA\IAR\" -I
#        "C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\ZASA\IAR\..\Source\" -I
#        "C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\ZASA\IAR\..\..\common\zaccel\" -I
#        "C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\ZASA\IAR\..\..\common\mt\" -I
#        "C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\ZASA\IAR\..\..\target\include\" -I
#        "C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\ZASA\IAR\..\..\target\cc2480\" --reduce_stack_usage -Ohz
#        --require_prototypes
#    List file     =  
#        C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\ZASA\IAR\Router\List\hal_board.lst
#    Object file   =  
#        C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE
#        M&M\ZASA\IAR\Router\Obj\hal_board.r43
#
###############################################################################

C:\Users\-____-\Dropbox\TIV3A-InternetRadio\KASPERRICK\ZIGBEE M&M\target\cc2480\hal_board.c
      1          /**************************************************************************************************
      2              Filename:       hal_board.c
      3              Revised:        $Date: 2008-03-28 15:13:08 -0700 (Fri, 28 Mar 2008) $
      4              Revision:       $Revision: 16675 $
      5          
      6              Description: Board specific implementations for the Z-Accel DB using the MSP430F2274.
      7          
      8              Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
      9          
     10              IMPORTANT: Your use of this Software is limited to those specific rights
     11              granted under the terms of a software license agreement between the user
     12              who downloaded the software, his/her employer (which must be your employer)
     13              and Texas Instruments Incorporated (the "License").  You may not use this
     14              Software unless you agree to abide by the terms of the License. The License
     15              limits your use, and you acknowledge, that the Software may not be modified,
     16              copied or distributed unless embedded on a Texas Instruments microcontroller
     17              or used solely and exclusively in conjunction with a Texas Instruments radio
     18              frequency transceiver, which is integrated into your product.  Other than for
     19              the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20              works of, modify, distribute, perform, display or sell this Software and/or
     21              its documentation for any purpose.
     22          
     23              YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24              PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25              INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26              NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27              TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28              NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29              LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30              INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31              OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32              OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33              (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35              Should you have any questions regarding your right to use this Software,
     36              contact Texas Instruments Incorporated at www.TI.com.
     37          **************************************************************************************************/
     38          
     39          /* ------------------------------------------------------------------------------------------------
     40           *                                          Includes
     41           * ------------------------------------------------------------------------------------------------
     42           */
     43          
     44          #include "hal_board.h"

   \                                 In  segment DATA16_AN, at 0x3
   \   unsigned char volatile IFG2
   \                     IFG2:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x4a
   \   unsigned char volatile ADC10AE0
   \                     ADC10AE0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1b0
   \   unsigned short volatile ADC10CTL0
   \                     ADC10CTL0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x1b2
   \   unsigned short volatile ADC10CTL1
   \                     ADC10CTL1:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x1b4
   \   unsigned short volatile ADC10MEM
   \                     ADC10MEM:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x56
   \   unsigned char volatile DCOCTL
   \                     DCOCTL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x57
   \   unsigned char volatile BCSCTL1
   \                     BCSCTL1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x53
   \   unsigned char volatile BCSCTL3
   \                     BCSCTL3:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x21
   \   unsigned char volatile P1OUT
   \                     P1OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x22
   \   unsigned char volatile P1DIR
   \                     P1DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x23
   \   unsigned char volatile P1IFG
   \                     P1IFG:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x24
   \   unsigned char volatile P1IES
   \                     P1IES:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x25
   \   unsigned char volatile P1IE
   \                     P1IE:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x26
   \   unsigned char volatile P1SEL
   \                     P1SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x27
   \   unsigned char volatile P1REN
   \                     P1REN:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x28
   \   unsigned char const volatile P2IN
   \                     P2IN:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x29
   \   unsigned char volatile P2OUT
   \                     P2OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2a
   \   unsigned char volatile P2DIR
   \                     P2DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2b
   \   unsigned char volatile P2IFG
   \                     P2IFG:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2c
   \   unsigned char volatile P2IES
   \                     P2IES:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2d
   \   unsigned char volatile P2IE
   \                     P2IE:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2e
   \   unsigned char volatile P2SEL
   \                     P2SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2f
   \   unsigned char volatile P2REN
   \                     P2REN:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x19
   \   unsigned char volatile P3OUT
   \                     P3OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1a
   \   unsigned char volatile P3DIR
   \                     P3DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1b
   \   unsigned char volatile P3SEL
   \                     P3SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1d
   \   unsigned char volatile P4OUT
   \                     P4OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1e
   \   unsigned char volatile P4DIR
   \                     P4DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1f
   \   unsigned char volatile P4SEL
   \                     P4SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x160
   \   unsigned short volatile TACTL
   \                     TACTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x162
   \   unsigned short volatile TACCTL0
   \                     TACCTL0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x170
   \   unsigned short volatile TAR
   \                     TAR:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x172
   \   unsigned short volatile TACCR0
   \                     TACCR0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x180
   \   unsigned short volatile TBCTL
   \                     TBCTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x192
   \   unsigned short volatile TBCCR0
   \                     TBCCR0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x68
   \   unsigned char volatile UCB0CTL0
   \                     UCB0CTL0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x69
   \   unsigned char volatile UCB0CTL1
   \                     UCB0CTL1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x6a
   \   unsigned char volatile UCB0BR0
   \                     UCB0BR0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x6b
   \   unsigned char volatile UCB0BR1
   \                     UCB0BR1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x6e
   \   unsigned char const volatile UCB0RXBUF
   \                     UCB0RXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x6f
   \   unsigned char volatile UCB0TXBUF
   \                     UCB0TXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x120
   \   unsigned short volatile WDTCTL
   \                     WDTCTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x10fc
   \   unsigned char const volatile CALDCO_8MHZ
   \                     CALDCO_8MHZ:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x10fd
   \   unsigned char const volatile CALBC1_8MHZ
   \                     CALBC1_8MHZ:
   \   000000                DS8 1
     45          
     46          /* ------------------------------------------------------------------------------------------------
     47           *                                           Constants
     48           * ------------------------------------------------------------------------------------------------
     49           */
     50          
     51          // Count for ~20msec - ADC needs 17msec for refV to settle.
     52          #define ADC_WAIT_MSECS         20
     53          
     54          // Debounce for ~10msec.
     55          #define DEBOUNCE_MSECS         10
     56          
     57          /* ------------------------------------------------------------------------------------------------
     58           *                                           Macros
     59           * ------------------------------------------------------------------------------------------------
     60           */
     61          
     62          #define _PRAGMA(x) _Pragma(#x)
     63          #define HAL_ISR_FUNC_DECLARATION(f,v) _PRAGMA(vector=v) __interrupt void f(void)
     64          #define HAL_ISR_FUNC_PROTOTYPE(f)     __interrupt void f(void)
     65          #define HAL_ISR_FUNCTION(f,v)         HAL_ISR_FUNC_PROTOTYPE(f); HAL_ISR_FUNC_DECLARATION(f,v)
     66          
     67          /* Whereas a customer application may require one or more slaves on the SPI bus (which could be
     68           * but are not necessarily other ZACCEL modules).
     69           * Whereas it may be necessary to interrupt any message exchange on the SPI bus with any of the
     70           * slaves in order to exchange a message with a different (obviously higher priority) slave, and
     71           * then return to finish the original message with the original slave.
     72           * Therefore it is necessary that setting and clearing any particular slave select line be
     73           * physically separate from setting and clearing any particular protocol handshake.
     74           *
     75           * Whereas the RPC Protocol handshake requires that MRDY be set low and maintained low throughout
     76           * the possibly several, logically contiguous, exchanges of RPC commands on the SPI bus.
     77           * Whereas the cc2480 has the MPC430 host wired to only one ZACCEL slave on the SPI bus.
     78           * Therefore it was deemed simpler and easier to understand on a logical analyzer trace of the SPI
     79           * and RPC signals for the setting and clearing of the MRDY control line to be tied to the setting
     80           * and clearing of the slave select line.
     81           *
     82           * It may better serve the user to remove the control of the slave select line from the control of
     83           * the MRDY line and place it here, where it belongs, in the 4-wire SPI protocol control.
     84           *
     85           * Also to note: the cc2480 SPI slave does not tri-state the MOSI line when its SS is not asserted,
     86           * thus requiring external de-coupling hardware in order to support two or more slaves on the bus.
     87           */
     88          #define SS_Clr()
     89          #define SS_Set()
     90          
     91          #define RST_Clr()       (P3OUT |= BV(7))
     92          #define RST_Set()       (P3OUT &= ~BV(7))
     93          
     94          /* ------------------------------------------------------------------------------------------------
     95           *                                           Global Variables
     96           * ------------------------------------------------------------------------------------------------
     97           */
     98          
     99          // Flags set by ISR's to indicate events without blocking or invoking background functions.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    100          volatile uint16 halEventFlags = HAL_EVT_NONE;
   \                     halEventFlags:
   \   000000                DS8 2
    101          
    102          // Last value read from the ADC by ISR.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    103          volatile uint16 halAdcVal = 0;
   \                     halAdcVal:
   \   000000                DS8 2
    104          
    105          /* ------------------------------------------------------------------------------------------------
    106           *                                           Local Variables
    107           * ------------------------------------------------------------------------------------------------
    108           */
    109          
    110          // Software timers w/ +/- 1 sec resolution and 65535 msec max.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    111          static volatile uint16 tmrTicks[HAL_TIMER_CNT];
   \                     tmrTicks:
   \   000000                DS8 8

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    112          static uint16 tmrPeriod[HAL_TIMER_CNT];
   \                     tmrPeriod:
   \   000000                DS8 8

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    113          uint16 TACCR0_INIT;
   \                     TACCR0_INIT:
   \   000000                DS8 2
    114          
    115          #ifdef HOST_MT
    116          static uint8 rx0Buf[ZACCEL_BUF_LEN];
    117          static volatile uint8 rx0Head;
    118          static volatile uint8 rx0Time;
    119          static uint8 rx0Tail;
    120          static uint8 tx0Buf[ZACCEL_BUF_LEN];
    121          static uint8 tx0Head;
    122          static volatile uint8 tx0Tail;
    123          #endif
    124          
    125          /* ------------------------------------------------------------------------------------------------
    126           *                                           Local Functions
    127           * ------------------------------------------------------------------------------------------------
    128           */
    129          
    130          static void ioInit(void);
    131          static void halMcuInit(void);
    132          static void halTimerInit(void);
    133          static void halSPIInit(void);
    134          void halSPIRead(uint8 sss, uint8 *pBuf, uint8 len);
    135          void halSPIWrite(uint8 sss, uint8 *pBuf, uint8 len);
    136          
    137          #define INTERRUPT_PORT1()    HAL_ISR_FUNCTION(isrPort1, PORT1_VECTOR)
    138          #define INTERRUPT_PORT2()    HAL_ISR_FUNCTION(isrPort2, PORT2_VECTOR)
    139          #define INTERRUPT_TIMERA()   HAL_ISR_FUNCTION(isrTimerA, TIMERA0_VECTOR)
    140          #define INTERRUPT_ADC10()    HAL_ISR_FUNCTION(isrADC, ADC10_VECTOR)
    141          
    142          #ifdef HOST_MT
    143          static void halUARTInit(void);
    144          void halUARTWrite(uint8 port, uint8 *pBuf, uint8 len);
    145          #define INTERRUPT_RX0()      HAL_ISR_FUNCTION(isrRx0, USCIAB0RX_VECTOR)
    146          #define INTERRUPT_TX0()      HAL_ISR_FUNCTION(isrTx0, USCIAB0TX_VECTOR)
    147          #endif
    148          
    149          /**************************************************************************************************
    150           * @fn          halBoardInit
    151           *
    152           * @brief       This is the HAL board main initialization function for ZASA.
    153           *
    154           * input parameters
    155           *
    156           * None.
    157           *
    158           * output parameters
    159           *
    160           * None.
    161           *
    162           * @return      None.
    163           **************************************************************************************************
    164           */

   \                                 In  segment CODE, align 2
    165          void halBoardInit(void)
   \                     halBoardInit:
    166          {
    167            ioInit();
   \   000000   B012....     CALL    #ioInit
    168            halMcuInit();
   \   000004   B012....     CALL    #halMcuInit
    169            halTimerInit();
   \   000008   B012....     CALL    #halTimerInit
    170            halSPIInit();
   \   00000C   D2436900     MOV.B   #0x1, &0x69
   \   000010   F240A9006800 MOV.B   #0xa9, &0x68
   \   000016   F2D080006900 BIS.B   #0x80, &0x69
   \   00001C   8293....     CMP.W   #0x0, &halEventFlags
   \   000020   0338         JL      ??halBoardInit_0
   \   000022   7E400300     MOV.B   #0x3, R14
   \   000026   013C         JMP     ??halBoardInit_1
   \                     ??halBoardInit_0:
   \   000028   5E43         MOV.B   #0x1, R14
   \                     ??halBoardInit_1:
   \   00002A   C24E6A00     MOV.B   R14, &0x6a
   \   00002E   C2436B00     MOV.B   #0x0, &0x6b
   \   000032   F2D00E001B00 BIS.B   #0xe, &0x1b
   \   000038   D2C36900     BIC.B   #0x1, &0x69
    171          #ifdef HOST_MT
    172            halUARTInit();
    173          #endif
    174            halEventFlags = HAL_EVT_NONE;   // Clear event flags
   \   00003C   8243....     MOV.W   #0x0, &halEventFlags
    175          }
   \   000040   3041         RET
   \   000042                REQUIRE UCB0CTL1
   \   000042                REQUIRE UCB0CTL0
   \   000042                REQUIRE UCB0BR0
   \   000042                REQUIRE UCB0BR1
   \   000042                REQUIRE P3SEL
    176          
    177          /**************************************************************************************************
    178           * @fn          halSlaveReset
    179           *
    180           * @brief       This function makes a clean reset of the slave Z-Accel device.
    181           *
    182           * input parameters
    183           *
    184           * None.
    185           *
    186           * output parameters
    187           *
    188           * None.
    189           *
    190           * @return      None.
    191           **************************************************************************************************
    192           */

   \                                 In  segment CODE, align 2
    193          void halSlaveReset(void)
   \                     halSlaveReset:
    194          {
    195            RST_Set();
   \   000000   F2C080001900 BIC.B   #0x80, &0x19
    196            halDelay(10, TRUE);
   \   000006   B012....     CALL    #?Subroutine2
    197            RST_Clr();
   \                     ??CrossCallReturnLabel_0:
   \   00000A   F2D080001900 BIS.B   #0x80, &0x19
    198            halDelay(250, TRUE);
   \   000010   5D43         MOV.B   #0x1, R13
   \   000012   7C40FA00     MOV.B   #0xfa, R12
   \   000016   B012....     CALL    #halDelay
    199            while (!SRDY());  // Wait for the Z-Accel slave to signal that it is out of reset.
   \                     ??halSlaveReset_0:
   \   00001A   F2B040002800 BIT.B   #0x40, &0x28
   \   000020   FC2F         JC      ??halSlaveReset_0
    200          }
   \   000022   3041         RET
   \   000024                REQUIRE P3OUT
   \   000024                REQUIRE P2IN

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   5D43         MOV.B   #0x1, R13
   \   000002   7C400A00     MOV.B   #0xa, R12
   \   000006   3040....     BR      #halDelay
    201          
    202          /**************************************************************************************************
    203           * @fn          ioInit
    204           *
    205           * @brief       This function initializes the DIO.
    206           *              MSP430x2xx: 6.2.7 Configuring Unused Port Pins
    207           *              Unused I/O pins should be configured as I/O function, output direction,
    208           *              and left unconnected on the PC board, to prevent a floating input and reduce power
    209           *              consumption. The value of the PxOUT bit is a don’t care.
    210           *
    211           * input parameters
    212           *
    213           * None.
    214           *
    215           * output parameters
    216           *
    217           * None.
    218           *
    219           * @return      None.
    220           **************************************************************************************************
    221           */

   \                                 In  segment CODE, align 2
    222          static void ioInit(void)
   \                     ioInit:
    223          {
    224            /* P1.0/1 are DO to control LED_1/2, active high.
    225             * P1.2 is a DI w/ int. pull-up high to receive switch press interrupt.
    226             */
    227            P1SEL = 0x00;
   \   000000   C2432600     MOV.B   #0x0, &0x26
    228            P1OUT = 0xFC;
   \   000004   F240FC002100 MOV.B   #0xfc, &0x21
    229            P1DIR = 0xFB;
   \   00000A   F240FB002200 MOV.B   #0xfb, &0x22
    230          
    231            /* Configure the push button for ISR on press down.
    232             */
    233            P1REN = SW1_BV;
   \   000010   E2422700     MOV.B   #0x4, &0x27
    234            P1IES = SW1_BV;
   \   000014   E2422400     MOV.B   #0x4, &0x24
    235            P1IFG = 0;
   \   000018   C2432300     MOV.B   #0x0, &0x23
    236            P1IE  = SW1_BV;
   \   00001C   E2422500     MOV.B   #0x4, &0x25
    237          
    238            /* P2.0 is the light sensor input to ADC10-0.
    239             * P2.1 is the light sensor input enable - set high to read ADC, then low to save power.
    240             */
    241            P2SEL = 0x01;
   \   000020   D2432E00     MOV.B   #0x1, &0x2e
    242            P2OUT = 0xDD;
   \   000024   F240DD002900 MOV.B   #0xdd, &0x29
    243            P2DIR = 0xBA; //0xBE; //leave P2.2 as input (0)
   \   00002A   F240BA002A00 MOV.B   #0xba, &0x2a
    244            P2REN |= BV(2); //enable pull-up on P2.2
   \   000030   E2D22F00     BIS.B   #0x4, &0x2f
    245            
    246            /* P2.6 is a DI to receive SRDY (Slave Ready on RPC protocol.)
    247             * Configure the SRDY for ISR on active low so that slave does not timeout awaiting the RPC
    248             * handshake sequence and reset.
    249             */
    250            P2REN |= BV(6);
   \   000034   F2D040002F00 BIS.B   #0x40, &0x2f
    251            HAL_CFG_SRDY_ISR;
   \   00003A   F24040002C00 MOV.B   #0x40, &0x2c
    252            P2IFG = 0;
   \   000040   C2432B00     MOV.B   #0x0, &0x2b
    253            P2IE  = BV(6);
   \   000044   F24040002D00 MOV.B   #0x40, &0x2d
    254          
    255            /* P2.3 is a DI (M.W.)
    256             * P2.3 pull up resistor enabled
    257             */
    258            P2DIR &= ~BV(3);
   \   00004A   F2C22A00     BIC.B   #0x8, &0x2a
    259            P2REN |= BV(3);
   \   00004E   F2D22F00     BIS.B   #0x8, &0x2f
    260            
    261            /* P3.0 is a DO to control SSn (Slave Select Not = active low.)
    262             * P3.6 is a DO to control MRDY (Master Ready on RPC protocol.)
    263             * P3.7 is a DO to control RSTn (Slave RESET Not = active low asserted.)
    264             */
    265            P3SEL = 0x00;
   \   000052   C2431B00     MOV.B   #0x0, &0x1b
    266            P3OUT = 0x7F;
   \   000056   F2407F001900 MOV.B   #0x7f, &0x19
    267            P3DIR = 0xFF;
   \   00005C   F2431A00     MOV.B   #0xff, &0x1a
    268          
    269            /* P4.0 is a DO to control Cfg0 (Slave Configuration Switch 0.)
    270             * - Set high configures slave to use 32-kHz crystal installed and used.
    271             * - Set low configures slave to use internal oscillator.
    272             * P4.1 is a DO to control Cfg1 (Slave Configuration Switch 1.)
    273             * - Set high configures slave to use SPI transport.
    274             * - Set low configures slave to use UART transport.
    275             *
    276             * P4.3.is a DO to control a door motor (M.W.)
    277             * - Set high to close the door
    278             * - Set low to open
    279             */
    280            P4SEL = 0x00;
   \   000060   C2431F00     MOV.B   #0x0, &0x1f
    281            P4OUT = 0xFF;
   \   000064   F2431D00     MOV.B   #0xff, &0x1d
    282            P4DIR = 0xFF;
   \   000068   F2431E00     MOV.B   #0xff, &0x1e
    283          }
   \   00006C   3041         RET
   \   00006E                REQUIRE P1SEL
   \   00006E                REQUIRE P1OUT
   \   00006E                REQUIRE P1DIR
   \   00006E                REQUIRE P1REN
   \   00006E                REQUIRE P1IES
   \   00006E                REQUIRE P1IFG
   \   00006E                REQUIRE P1IE
   \   00006E                REQUIRE P2SEL
   \   00006E                REQUIRE P2OUT
   \   00006E                REQUIRE P2DIR
   \   00006E                REQUIRE P2REN
   \   00006E                REQUIRE P2IES
   \   00006E                REQUIRE P2IFG
   \   00006E                REQUIRE P2IE
   \   00006E                REQUIRE P3SEL
   \   00006E                REQUIRE P3OUT
   \   00006E                REQUIRE P3DIR
   \   00006E                REQUIRE P4SEL
   \   00006E                REQUIRE P4OUT
   \   00006E                REQUIRE P4DIR
    284          
    285          /**************************************************************************************************
    286           * @fn          halMcuInit
    287           *
    288           * @brief       Turn off watchdog and set up system clock. Set system clock to 8 MHz if Vdd permits.
    289           *
    290           * input parameters
    291           *
    292           * None.
    293           *
    294           * output parameters
    295           *
    296           * None.
    297           *
    298           * @return      None.
    299           **************************************************************************************************
    300           */

   \                                 In  segment CODE, align 2
    301          static void halMcuInit(void)
   \                     halMcuInit:
    302          {
   \   000000   2183         SUB.W   #0x2, SP
    303            volatile uint16 tmp;
    304          
    305            WDTCTL = WDTPW | WDTHOLD;           // Disable the watchdog.
   \   000002   B240805A2001 MOV.W   #0x5a80, &0x120
    306          
    307            // Setup code taken from TI example code: msp430x22x4_adc11_temp.c.
    308            ADC10CTL1 = INCH_11 + ADC10DIV_3;   // Internal bus voltage, ADC10CLK/4
   \   000008   B24060B0B201 MOV.W   #0xb060, &0x1b2
    309            ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE;
   \   00000E   B2403830B001 MOV.W   #0x3038, &0x1b0
    310          
    311            /* Allow Vdd to settle before reading it and re-configuring the system clock.
    312             * MSP FAE confirmed that it can take up to 1 second for the Vdd to settle.
    313             */
    314            __delay_cycles(250);
   \   000014                ////////////// Start of 250 cycles delay.
   \   000014   003C         JMP     ??halMcuInit_3
   \                     ??halMcuInit_3:
   \   000016   3F405100     MOV.W   #0x51, R15
   \                     ??halMcuInit_2:
   \   00001A   3F53         ADD.W   #0xffff, R15
   \   00001C   FE2F         JC      ??halMcuInit_2
   \   00001E                ////////////// End of delay code.
    315          
    316            ADC10CTL0 |= ENC + ADC10SC;         // Sampling and conversion start.
   \   00001E   B2D00300B001 BIS.W   #0x3, &0x1b0
    317            __low_power_mode_1();               // Low power during sampling period.
   \   000024   32D05800     BIS.W   #0x58, SR
    318          
    319            // Measurement of AVcc/2 is in range 0 to 1023 indicating voltage from 0 to 1.5V.
    320            tmp = (halAdcVal * 30 + 512) >> 10; // Convert to units of 0.1V
   \   000028   1F42....     MOV.W   &halAdcVal, R15
   \   00002C   0F5F         RLA.W   R15
   \   00002E   0E4F         MOV.W   R15, R14
   \   000030   0F5F         RLA.W   R15
   \   000032   0E5F         ADD.W   R15, R14
   \   000034   0F5F         RLA.W   R15
   \   000036   0E5F         ADD.W   R15, R14
   \   000038   0F5F         RLA.W   R15
   \   00003A   0F5E         ADD.W   R14, R15
   \   00003C   3F500002     ADD.W   #0x200, R15
   \   000040   8F10         SWPB    R15
   \   000042   7FF3         AND.B   #0xff, R15
   \   000044   0F11         RRA.W   R15
   \   000046   0F11         RRA.W   R15
   \   000048   814F0000     MOV.W   R15, 0(SP)
    321          
    322            // Cannont use 8-MHz if the Calibration values have been erased or if the bus voltage < 2.2V.
    323            if ((tmp >= 22) && (CALBC1_8MHZ != 0xFF) && (CALDCO_8MHZ != 0xFF))
   \   00004C   B19016000000 CMP.W   #0x16, 0(SP)
   \   000052   0D28         JNC     ??halMcuInit_0
   \   000054   F293FD10     CMP.B   #0xff, &0x10fd
   \   000058   0A24         JEQ     ??halMcuInit_0
   \   00005A   F293FC10     CMP.B   #0xff, &0x10fc
   \   00005E   0724         JEQ     ??halMcuInit_0
    324            {
    325              // Configure the system clock for 8-MHz by loading the calibrated values from the info memory.
    326              BCSCTL1 = CALBC1_8MHZ;
   \   000060   D242FD105700 MOV.B   &0x10fd, &0x57
    327              DCOCTL = CALDCO_8MHZ;
   \   000066   D242FC105600 MOV.B   &0x10fc, &0x56
   \   00006C   033C         JMP     ??halMcuInit_1
    328            }
    329            else
    330            {
    331              halEventFlags |= HAL_EVT_NO_8MHz;
   \                     ??halMcuInit_0:
   \   00006E   B2D00080.... BIS.W   #0x8000, &halEventFlags
    332            }
    333          }
   \                     ??halMcuInit_1:
   \   000074   2153         ADD.W   #0x2, SP
   \   000076   3041         RET
   \   000078                REQUIRE WDTCTL
   \   000078                REQUIRE ADC10CTL1
   \   000078                REQUIRE ADC10CTL0
   \   000078                REQUIRE CALBC1_8MHZ
   \   000078                REQUIRE CALDCO_8MHZ
   \   000078                REQUIRE BCSCTL1
   \   000078                REQUIRE DCOCTL
    334          
    335          /**************************************************************************************************
    336           * @fn          halTimerInit
    337           *
    338           * @brief       Turn off watchdog and set up system clock. Set system clock to 8 MHz.
    339           *
    340           * input parameters
    341           *
    342           * None.
    343           *
    344           * output parameters
    345           *
    346           * None.
    347           *
    348           * @return      None.
    349           **************************************************************************************************
    350           */

   \                                 In  segment CODE, align 2
    351          static void halTimerInit(void)
   \                     halTimerInit:
    352          {
    353            uint8 loop = 128;         // Count 8mHz by 65536 timer overflow.
   \   000000   7E408000     MOV.B   #0x80, R14
    354          
    355            if (halEventFlags & HAL_EVT_NO_8MHz)
   \   000004   8293....     CMP.W   #0x0, &halEventFlags
   \   000008   0234         JGE     ??halTimerInit_1
    356            {
    357              loop = 16;              // Count 1mHz by 65536 timer overflow.
   \   00000A   7E401000     MOV.B   #0x10, R14
    358            }
    359          
    360            BCSCTL1 |= DIVA_3;        // ACLK/8
   \                     ??halTimerInit_1:
   \   00000E   F2D030005700 BIS.B   #0x30, &0x57
    361            BCSCTL3 |= LFXT1S_2;      // ACLK = VLO
   \   000014   F2D020005300 BIS.B   #0x20, &0x53
    362          
    363            // Setup TimerB to calibrate TimerA.
    364            TBCCR0 = 65535;
   \   00001A   B2439201     MOV.W   #0xffff, &0x192
    365          
    366            // Setup TimerA to be calibrated.
    367            TACCR0 = 65535;
   \   00001E   B2437201     MOV.W   #0xffff, &0x172
    368            TACTL = TASSEL_1 + MC_1;  // ACLK, up count mode.
   \   000022   B24010016001 MOV.W   #0x110, &0x160
    369          
    370            // Calibrate TimerA.
    371            TBCTL = TBSSEL_2 + MC_1;  // SMCLK, up count mode.
   \   000028   B24010028001 MOV.W   #0x210, &0x180
    372          
    373            do {
    374              while ((TBCTL & TBIFG) == 0);
   \                     ??halTimerInit_0:
   \   00002E   92B38001     BIT.W   #0x1, &0x180
   \   000032   FD2B         JNC     ??halTimerInit_0
    375              TBCTL &= ~TBIFG;
   \   000034   92C38001     BIC.W   #0x1, &0x180
    376            } while (--loop);
   \   000038   7E53         ADD.B   #0xff, R14
   \   00003A   F923         JNE     ??halTimerInit_0
    377            TBCTL = TBCLR;            // Clear TimerB configuration.
   \   00003C   A2428001     MOV.W   #0x4, &0x180
    378          
    379            TACTL &= ~MC_1;           // Stop TimerA.
   \   000040   B2C010006001 BIC.W   #0x10, &0x160
    380            TACCR0_INIT = TAR;
   \   000046   1F427001     MOV.W   &0x170, R15
   \   00004A   824F....     MOV.W   R15, &TACCR0_INIT
    381            TACTL |= MC_1;            // Resume TimerA.
   \   00004E   B2D010006001 BIS.W   #0x10, &0x160
    382          
    383            // Configure TimerA for 1-msec ISR for driving the HAL S/W timers, timing key press+hold, etc.
    384            TACCR0 = TACCR0_INIT;     // 1 second by 12kHz / 8 -> 1.5kHz
   \   000054   824F7201     MOV.W   R15, &0x172
    385            TACCTL0 = CCIE;           // TACCR0 interrupt enabled
   \   000058   B24010006201 MOV.W   #0x10, &0x162
    386          }
   \   00005E   3041         RET
   \   000060                REQUIRE BCSCTL1
   \   000060                REQUIRE BCSCTL3
   \   000060                REQUIRE TBCCR0
   \   000060                REQUIRE TACCR0
   \   000060                REQUIRE TACTL
   \   000060                REQUIRE TBCTL
   \   000060                REQUIRE TAR
   \   000060                REQUIRE TACCTL0
    387          
    388          /**************************************************************************************************
    389           * @fn          halSPIInit
    390           *
    391           * @brief       This function initializes the SPI.
    392           *
    393           * input parameters
    394           *
    395           * None.
    396           *
    397           * output parameters
    398           *
    399           * None.
    400           *
    401           * @return      None.
    402           **************************************************************************************************
    403           */
    404          static void halSPIInit(void)
    405          {
    406            /* Set SWRST - UART logic held in reset state during configuration. */
    407            UCB0CTL1 = UCSWRST;
    408          
    409            /* Configure for Mastermode; 3-pin SPI mode; 8 bits per byte. */
    410            UCB0CTL0 = UCCKPH | UCMSB | UCMST | UCSYNC;
    411          
    412            // Configure baud for ~2.7 MB (8-MHz/3), or max without an 8-MHz system clock.
    413            UCB0CTL1 |= UCSSEL_2;
    414            if (halEventFlags & HAL_EVT_NO_8MHz)
    415            {
    416              UCB0BR0 = 0x01;
    417            }
    418            else
    419            {
    420              UCB0BR0 = 0x03;
    421            }
    422            UCB0BR1 = 0x00;
    423          
    424            P3SEL |= 0x0E;   // Select SPI functionality on DIO pins for MOSI, MISO, & CLK.
    425          
    426            /* Clear SWRST - release reset to operation */
    427            UCB0CTL1 &= ~UCSWRST;
    428          }
    429          
    430          /**************************************************************************************************
    431           * @fn          halSPIWrite
    432           *
    433           * @brief       This function blocks (polling) on the SPI port transaction. Note that the SPI
    434           *              master (this host application) must write in order to read, so this one write
    435           *              function has such a dual use in the code.
    436           *
    437           * input parameters
    438           *
    439           * @param       sss - SPI Slave to select
    440           * @param       pBuf - Pointer to the buffer that contains the data to transmit.
    441           * @param       len - Length of the data to transmit.
    442           *
    443           * output parameters
    444           *
    445           * @param       pBuf - Pointer to the buffer that gets filled with the Rx bytes.
    446           *
    447           * @return      None.
    448           **************************************************************************************************
    449           */

   \                                 In  segment CODE, align 2
    450          void halSPIWrite(uint8 sss, uint8 *pBuf, uint8 len)
   \                     halSPIWrite:
    451          {
    452            if (sss == HAL_SPI_ZACCEL)
   \   000000   4C93         CMP.B   #0x0, R12
   \   000002   0E20         JNE     ??halSPIWrite_2
   \   000004   093C         JMP     ??halSPIWrite_3
    453            {
    454              SS_Set();
    455          
    456              while (len--)
    457              {
    458                UCB0TXBUF = *pBuf;
   \                     ??halSPIWrite_1:
   \   000006   E24D6F00     MOV.B   @R13, &0x6f
    459                while (!(IFG2 & UCB0RXIFG));
   \                     ??halSPIWrite_0:
   \   00000A   E2B20300     BIT.B   #0x4, &0x3
   \   00000E   FD2B         JNC     ??halSPIWrite_0
    460                *pBuf++ = UCB0RXBUF;
   \   000010   DD426E000000 MOV.B   &0x6e, 0(R13)
   \   000016   1D53         ADD.W   #0x1, R13
    461              }
   \                     ??halSPIWrite_3:
   \   000018   4F4E         MOV.B   R14, R15
   \   00001A   7E53         ADD.B   #0xff, R14
   \   00001C   4F93         CMP.B   #0x0, R15
   \   00001E   F323         JNE     ??halSPIWrite_1
    462          
    463              SS_Clr();
    464            }
    465          }
   \                     ??halSPIWrite_2:
   \   000020   3041         RET
   \   000022                REQUIRE UCB0TXBUF
   \   000022                REQUIRE IFG2
   \   000022                REQUIRE UCB0RXBUF
    466          
    467          /**************************************************************************************************
    468           * @fn          halTimerSet
    469           *
    470           * @brief       This function sets the timer period and control flags as specified.
    471           *
    472           * input parameters
    473           *
    474           * @param       tIdx - HAL Timer index.
    475           * @param       period - Timer period in msecs (zero to turn off.)
    476           * @param       ctlFlags - Bit mask of timer control flags.
    477           *
    478           * output parameters
    479           *
    480           * None.
    481           *
    482           * @return      None.
    483           **************************************************************************************************
    484           */

   \                                 In  segment CODE, align 2
    485          void halTimerSet(uint8 tIdx, uint16 period, uint8 ctlFlags)
   \                     halTimerSet:
    486          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4F4C         MOV.B   R12, R15
    487            halIntState_t s;
    488          
    489            if (ctlFlags & HAL_TIMER_AUTO)
   \   000004   4C4F         MOV.B   R15, R12
   \   000006   0C5C         RLA.W   R12
   \   000008   5EB3         BIT.B   #0x1, R14
   \   00000A   0328         JNC     ??halTimerSet_0
    490            {
    491              tmrPeriod[tIdx] = period;
   \   00000C   8C4D....     MOV.W   R13, tmrPeriod(R12)
   \   000010   023C         JMP     ??halTimerSet_1
    492            }
    493            else
    494            {
    495              tmrPeriod[tIdx] = 0;
   \                     ??halTimerSet_0:
   \   000012   8C43....     MOV.W   #0x0, tmrPeriod(R12)
    496            }
    497          
    498            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??halTimerSet_1:
   \   000016   0A42         MOV.W   SR, R10
   \   000018   32C2         dint
   \   00001A   0343         nop
    499            tmrTicks[tIdx] = period;
   \   00001C   8C4D....     MOV.W   R13, tmrTicks(R12)
    500            halEventFlags &= ~BV(tIdx);
   \   000020   1C43         MOV.W   #0x1, R12
   \   000022   4E4F         MOV.B   R15, R14
   \   000024   B012....     CALL    #?ShiftLeft16
   \   000028   82CC....     BIC.W   R12, &halEventFlags
    501            HAL_EXIT_CRITICAL_SECTION(s);
   \   00002C   024A         MOV.W   R10, SR
    502          }
   \   00002E   3A41         POP.W   R10
   \   000030   3041         RET
    503          
    504          /**************************************************************************************************
    505           * @fn          halDelay
    506           *
    507           * @brief       Delay for milliseconds.
    508           *              Do not invoke with zero.
    509           *              Do not invoke with greater than 500 msecs.
    510           *              Invoking with very high frequency and/or with long delays will start to
    511           *              significantly impact the real time performance of TimerA tasks because this will
    512           *              invisibly overrun the period when the TimerA count remaining, when this function
    513           *              is invoked, is less than the delay requested.
    514           *
    515           * input parameters
    516           *
    517           * @param       msecs - Milliseconds to delay in low power mode.
    518           * @param       sleep - Enforces blocking delay in low power mode if set.
    519           *
    520           * output parameters
    521           *
    522           * None.
    523           *
    524           * @return      None.
    525           **************************************************************************************************
    526           */

   \                                 In  segment CODE, align 2
    527          void halDelay(uint8 msecs, uint8 sleep)
   \                     halDelay:
    528          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   4A4D         MOV.B   R13, R10
    529            // Scaling for msecs depends on result of TimerA calibration.
    530            // stop = msecs * TACCR0_INIT / 1000
    531            // Division by 10 to prevent overflow:
    532            //
    533            uint16 stop = msecs * (TACCR0_INIT / 10) / (1000 / 10);
   \   000008   3B40....     MOV.W   #TACCR0_INIT, R11
   \   00000C   4C4C         MOV.B   R12, R12
   \   00000E   084C         MOV.W   R12, R8
   \   000010   2C4B         MOV.W   @R11, R12
   \   000012   3E400A00     MOV.W   #0xa, R14
   \   000016   B012....     CALL    #?DivMod16u
   \   00001A   0E4C         MOV.W   R12, R14
   \   00001C   0C48         MOV.W   R8, R12
   \   00001E   B012....     CALL    #?Mul16
   \   000022   3E406400     MOV.W   #0x64, R14
   \   000026   B012....     CALL    #?DivMod16u
    534          
    535            HAL_DISABLE_INTERRUPTS();
   \   00002A   32C2         dint
   \   00002C   0343         nop
    536            TACTL &= ~MC_1;         // Stop the timer.
   \   00002E   B2C010006001 BIC.W   #0x10, &0x160
    537          
    538            if (TAR != TACCR0_INIT)
   \   000034   A29B7001     CMP.W   @R11, &0x170
   \   000038   0524         JEQ     ??halDelay_1
    539            {
    540              stop += TAR;
   \   00003A   1C527001     ADD.W   &0x170, R12
    541              if (stop == TACCR0_INIT)
   \   00003E   2C9B         CMP.W   @R11, R12
   \   000040   0120         JNE     ??halDelay_1
    542              {
    543                stop++;
   \   000042   1C53         ADD.W   #0x1, R12
    544              }
    545            }
    546            TACCR0 = stop;
   \                     ??halDelay_1:
   \   000044   824C7201     MOV.W   R12, &0x172
    547          
    548            TACTL |= MC_1;          // Re-start the timer.
   \   000048   B2D010006001 BIS.W   #0x10, &0x160
    549            HAL_ENABLE_INTERRUPTS();
   \   00004E   32D2         eint
    550          
    551            if (sleep)
   \   000050   4A93         CMP.B   #0x0, R10
   \   000052   0524         JEQ     ??halDelay_2
    552            {
    553              do {
    554                HAL_LOW_POWER_MODE();
   \                     ??halDelay_0:
   \   000054   32D0D800     BIS.W   #0xd8, SR
    555              } while (TACCR0 != TACCR0_INIT);
   \   000058   A29B7201     CMP.W   @R11, &0x172
   \   00005C   FB23         JNE     ??halDelay_0
    556            }
    557          }
   \                     ??halDelay_2:
   \   00005E   3040....     BR      #?Epilogue3
   \   000062                REQUIRE TACTL
   \   000062                REQUIRE TAR
   \   000062                REQUIRE TACCR0
    558          
    559          /**************************************************************************************************
    560           * @fn          halDelayDone
    561           *
    562           * @brief       Check to determine if a requested HAL delay is done.
    563           *
    564           * input parameters
    565           *
    566           * None.
    567           *
    568           * output parameters
    569           *
    570           * None.
    571           *
    572           * @return      None.
    573           **************************************************************************************************
    574           */

   \                                 In  segment CODE, align 2
    575          uint8 halDelayDone(void)
   \                     halDelayDone:
    576          {
    577            return (TACCR0 == TACCR0_INIT);
   \   000000   9292....7201 CMP.W   &TACCR0_INIT, &0x172
   \   000006   0224         JEQ     ??halDelayDone_0
   \   000008   4C43         MOV.B   #0x0, R12
   \   00000A   3041         RET
   \                     ??halDelayDone_0:
   \   00000C   5C43         MOV.B   #0x1, R12
   \   00000E   3041         RET
   \   000010                REQUIRE TACCR0
    578          }
    579          
    580          #ifndef COORDINATOR
    581          /**************************************************************************************************
    582           * @fn          halReadTemp
    583           *
    584           * @brief       This function starts the ADC and sets up to read the channel for temperature.
    585           *
    586           * input parameters
    587           *
    588           * None.
    589           *
    590           * output parameters
    591           *
    592           * None.
    593           *
    594           * @return      None.
    595           **************************************************************************************************
    596           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine3_0:
   \   000000   5D43         MOV.B   #0x1, R13
   \   000002   7C401400     MOV.B   #0x14, R12
   \   000006   B012....     CALL    #halDelay
   \   00000A   B2D00300B001 BIS.W   #0x3, &0x1b0
   \   000010   3041         RET

   \                                 In  segment CODE, align 2
    597          void halReadTemp(void)
   \                     halReadTemp:
    598          {
    599            // Setup code taken from eZ430-RF2500 Temperature Sensor End Device.
    600            ADC10CTL1 = INCH_10 + ADC10DIV_4;       // Temp Sensor ADC10CLK/5
   \   000000   B24080A0B201 MOV.W   #0xa080, &0x1b2
    601            ADC10CTL0 = SREF_1 + ADC10SHT_3 + REFON + ADC10ON + ADC10IE + ADC10SR;
   \   000006   B240383CB001 MOV.W   #0x3c38, &0x1b0
    602          
    603            halDelay(ADC_WAIT_MSECS, TRUE);         // Allow Vref to ADC to charge.
   \   00000C   ....         JMP     ??Subroutine3_0
   \   00000E                REQUIRE ADC10CTL1
   \   00000E                REQUIRE ADC10CTL0
    604            ADC10CTL0 |= ENC | ADC10SC;             // Sampling and conversion start
    605          }
    606          
    607          /*******************************************************************************
    608          * @fn halLightSensorRead
    609          *
    610          * @brief Starts reading the value from the light sensor on a ZAccel node.
    611          * The value is ranging from 0x00 to 0x0400
    612          *
    613          * input parameters: None.
    614          * output parameters: None.
    615          * @return None.
    616          *******************************************************************************
    617          */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   B2403830B001 MOV.W   #0x3038, &0x1b0
   \   000006                REQUIRE ??Subroutine3_0
   \   000006                // Fall through to label ??Subroutine3_0

   \                                 In  segment CODE, align 2, keep-with-next
    618          void halLightSensorRead(void)
   \                     halLightSensorRead:
    619          {
    620           // Code partly taken from CC2480 Software Examples code (swru169.zip):
    621           P2OUT |= BIT1; // Turn on the light sensor
   \   000000   E2D32900     BIS.B   #0x2, &0x29
    622           ADC10AE0 |= 0x01; // Sample channel A0
   \   000004   D2D34A00     BIS.B   #0x1, &0x4a
    623           ADC10CTL1 = INCH_0 + ADC10DIV_3; // A0, ADC10CLK/4
   \   000008   B2406000B201 MOV.W   #0x60, &0x1b2
    624           ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE; // REF2_5V;
   \   00000E   ....         JMP     ?Subroutine1
   \   000010                REQUIRE P2OUT
   \   000010                REQUIRE ADC10AE0
   \   000010                REQUIRE ADC10CTL1
   \   000010                REQUIRE ADC10CTL0
    625           halDelay (ADC_WAIT_MSECS, TRUE); // Allow Vref the ADC to charge.
    626           ADC10CTL0 |= (ENC + ADC10SC); // Sampling and conversion start
    627          }
    628          
    629          /**************************************************************************************************
    630           * @fn          halReadBusV
    631           *
    632           * @brief       This function sets up to read the channel for bus voltage.
    633           *
    634           * input parameters
    635           *
    636           * None.
    637           *
    638           * output parameters
    639           *
    640           * None.
    641           *
    642           * @return      None.
    643           **************************************************************************************************
    644           */

   \                                 In  segment CODE, align 2, keep-with-next
    645          void halReadBusV(void)
   \                     halReadBusV:
    646          {
    647            // Setup code taken from TI example code: msp430x22x4_adc10_temp.c.
    648            ADC10CTL1 = INCH_11 + ADC10DIV_3;       // Internal bus voltage, ADC10CLK/4
   \   000000   B24060B0B201 MOV.W   #0xb060, &0x1b2
    649            ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE;
   \   000006                REQUIRE ?Subroutine1
   \   000006                REQUIRE ADC10CTL1
   \   000006                REQUIRE ADC10CTL0
   \   000006                // Fall through to label ?Subroutine1
    650          
    651            halDelay(ADC_WAIT_MSECS, TRUE);         // Allow Vref to ADC to charge.
    652            ADC10CTL0 |= ENC | ADC10SC;             // Sampling and conversion start
    653          }
    654          #endif
    655          
    656          /**************************************************************************************************
    657           * @fn          isrPort1
    658           *
    659           * @brief       This function services the Push Button interrupt.
    660           *
    661           * input parameters
    662           *
    663           * None.
    664           *
    665           * output parameters
    666           *
    667           * None.
    668           *
    669           * @return      None.
    670           **************************************************************************************************
    671           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   3E41         POP.W   R14
   \   000002   3F41         POP.W   R15
   \   000004   3C41         POP.W   R12
   \   000006   3D41         POP.W   R13
   \   000008   0013         RETI

   \                                 In  segment CODE, align 2
    672          INTERRUPT_PORT1()
   \                     isrPort1:
    673          {
   \   000000   0D12         PUSH.W  R13
   \   000002   0C12         PUSH.W  R12
   \   000004   0F12         PUSH.W  R15
   \   000006   0E12         PUSH.W  R14
    674            P1IE  = 0;
   \   000008   C2432500     MOV.B   #0x0, &0x25
    675            halDelay(DEBOUNCE_MSECS, TRUE);
   \   00000C   B012....     CALL    #?Subroutine2
    676            P1IFG = 0;
   \                     ??CrossCallReturnLabel_1:
   \   000010   C2432300     MOV.B   #0x0, &0x23
    677            P1IE  = SW1_BV;
   \   000014   E2422500     MOV.B   #0x4, &0x25
    678            halEventFlags |= HAL_EVT_BTN_PRESS;  // Signal that a key press+hold event has taken place.
   \   000018   B2D00001.... BIS.W   #0x100, &halEventFlags
    679          
    680            __low_power_mode_off_on_exit();
   \   00001E   B1C0F0000800 BIC.W   #0xf0, 0x8(SP)
    681          }
   \   000024   ....         JMP     ?Subroutine0
   \   000026                REQUIRE P1IE
   \   000026                REQUIRE P1IFG
    682          
    683          /**************************************************************************************************
    684           * @fn          isrPort2
    685           *
    686           * @brief       This function services the SRDY interrupt.
    687           *
    688           * input parameters
    689           *
    690           * None.
    691           *
    692           * output parameters
    693           *
    694           * None.
    695           *
    696           * @return      None.
    697           **************************************************************************************************
    698           */

   \                                 In  segment CODE, align 2, keep-with-next
    699          INTERRUPT_PORT2()
   \                     isrPort2:
    700          {
    701            P2IFG = 0;
   \   000000   C2432B00     MOV.B   #0x0, &0x2b
    702            /* A sleeping host just needs to wake on SRDY. No flag needs to be set since Application-level
    703             * logic automatically polls for an asynchronous message from the slave.
    704             */
    705            __low_power_mode_off_on_exit();
   \   000004   B1C0F0000000 BIC.W   #0xf0, 0(SP)
    706          }
   \   00000A   0013         RETI
   \   00000C                REQUIRE P2IFG
    707          
    708          /**************************************************************************************************
    709           * @fn          isrTimerA
    710           *
    711           * @brief       This function services the Timer-A interrupt.
    712           *
    713           * input parameters
    714           *
    715           * None.
    716           *
    717           * output parameters
    718           *
    719           * None.
    720           *
    721           * @return      None.
    722           **************************************************************************************************
    723           */

   \                                 In  segment CODE, align 2, keep-with-next
    724          INTERRUPT_TIMERA()
   \                     isrTimerA:
    725          {
   \   000000   0D12         PUSH.W  R13
   \   000002   0C12         PUSH.W  R12
   \   000004   0F12         PUSH.W  R15
   \   000006   0E12         PUSH.W  R14
   \   000008   9292....7201 CMP.W   &TACCR0_INIT, &0x172
   \   00000E   0F24         JEQ     ??isrTimerA_2
    726            uint8 idx;
    727          
    728            if (TACCR0 != TACCR0_INIT)
    729            {
    730              __low_power_mode_off_on_exit();
   \   000010   B1C0F0000800 BIC.W   #0xf0, 0x8(SP)
    731          
    732              if (TACCR0 < TACCR0_INIT)
   \   000016   1F42....     MOV.W   &TACCR0_INIT, R15
   \   00001A   829F7201     CMP.W   R15, &0x172
   \   00001E   032C         JC      ??isrTimerA_3
    733              {
    734                TACCR0 = TACCR0_INIT;
   \   000020   824F7201     MOV.W   R15, &0x172
    735                return;
   \   000024   223C         JMP     ??isrTimerA_1
    736              }
    737              TAR = 0;
   \                     ??isrTimerA_3:
   \   000026   82437001     MOV.W   #0x0, &0x170
    738              TACCR0 = TACCR0_INIT;
   \   00002A   824F7201     MOV.W   R15, &0x172
    739            }
    740          
    741          #ifdef HOST_MT
    742            if (rx0Time != 0)
    743            {
    744              // If an Rx byte is waiting.
    745              if (rx0Time >= HOST_MT_RX_OLD)
    746              {
    747                halEventFlags |= HAL_EVT_MT_RX_RDY;
    748                rx0Time = 0;
    749              }
    750              else
    751              {
    752                rx0Time++;
    753              }
    754            }
    755          #endif
    756          
    757            // Update all active S/W timers.
    758            for (idx = 0; idx < HAL_TIMER_CNT; idx++)
   \                     ??isrTimerA_2:
   \   00002E   4F43         MOV.B   #0x0, R15
    759            {
    760              if ((tmrTicks[idx] != 0) && (--tmrTicks[idx] == 0))
   \                     ??isrTimerA_0:
   \   000030   4E4F         MOV.B   R15, R14
   \   000032   0E5E         RLA.W   R14
   \   000034   8E93....     CMP.W   #0x0, tmrTicks(R14)
   \   000038   0F24         JEQ     ??isrTimerA_4
   \   00003A   1D4E....     MOV.W   tmrTicks(R14), R13
   \   00003E   3D53         ADD.W   #0xffff, R13
   \   000040   8E4D....     MOV.W   R13, tmrTicks(R14)
   \   000044   0920         JNE     ??isrTimerA_4
    761              {
    762                tmrTicks[idx] = tmrPeriod[idx];
   \   000046   9E4E........ MOV.W   tmrPeriod(R14), tmrTicks(R14)
    763                halEventFlags |= BV(idx);
   \   00004C   1C43         MOV.W   #0x1, R12
   \   00004E   4E4F         MOV.B   R15, R14
   \   000050   B012....     CALL    #?ShiftLeft16
   \   000054   82DC....     BIS.W   R12, &halEventFlags
    764              }
    765            }
   \                     ??isrTimerA_4:
   \   000058   5F53         ADD.B   #0x1, R15
   \   00005A   6F92         CMP.B   #0x4, R15
   \   00005C   E92B         JNC     ??isrTimerA_0
    766          
    767            if (halEventFlags != HAL_EVT_NONE)
   \   00005E   8293....     CMP.W   #0x0, &halEventFlags
   \   000062   0324         JEQ     ??isrTimerA_1
    768            {
    769              __low_power_mode_off_on_exit();
   \   000064   B1C0F0000800 BIC.W   #0xf0, 0x8(SP)
    770            }
    771          }
   \                     ??isrTimerA_1:
   \   00006A                REQUIRE ?Subroutine0
   \   00006A                REQUIRE TACCR0
   \   00006A                REQUIRE TAR
   \   00006A                // Fall through to label ?Subroutine0
    772          
    773          /**************************************************************************************************
    774           * @fn          isrADC
    775           *
    776           * @brief       This function services the ADC interrupt.
    777           *
    778           * input parameters
    779           *
    780           * None.
    781           *
    782           * output parameters
    783           *
    784           * None.
    785           *
    786           * @return      None.
    787           **************************************************************************************************
    788           */

   \                                 In  segment CODE, align 2
    789          INTERRUPT_ADC10()
   \                     isrADC:
    790          {
    791            halAdcVal = ADC10MEM;             // Get sample from ADC
   \   000000   9242B401.... MOV.W   &0x1b4, &halAdcVal
    792            halEventFlags |= HAL_EVT_ADC;     // Signal that the ADC sample is ready.
   \   000006   B2D00002.... BIS.W   #0x200, &halEventFlags
    793          
    794            ADC10CTL0 &= ~ENC;                // Disable the ADC
   \   00000C   A2C3B001     BIC.W   #0x2, &0x1b0
    795            ADC10CTL0 &= ~(REFON + ADC10ON);  // Turn off A/D to save power
   \   000010   B2F0CFFFB001 AND.W   #0xffcf, &0x1b0
    796          
    797            __low_power_mode_off_on_exit();
   \   000016   B1C0F0000000 BIC.W   #0xf0, 0(SP)
    798            P2OUT &= ~BIT1;                   // Turn off the light sensor
   \   00001C   E2C32900     BIC.B   #0x2, &0x29
    799          }
   \   000020   0013         RETI
   \   000022                REQUIRE ADC10MEM
   \   000022                REQUIRE ADC10CTL0
   \   000022                REQUIRE P2OUT

   \                                 In  segment INTVEC, offset 0x4, root
   \                     `??isrPort1::??INTVEC 4`:
   \   000004   ....         DC16    isrPort1

   \                                 In  segment INTVEC, offset 0x6, root
   \                     `??isrPort2::??INTVEC 6`:
   \   000006   ....         DC16    isrPort2

   \                                 In  segment INTVEC, offset 0xa, root
   \                     `??isrADC::??INTVEC 10`:
   \   00000A   ....         DC16    isrADC

   \                                 In  segment INTVEC, offset 0x12, root
   \                     `??isrTimerA::??INTVEC 18`:
   \   000012   ....         DC16    isrTimerA
    800          
    801          #ifdef HOST_MT
    802          /**************************************************************************************************
    803           * @fn          halUARTInit
    804           *
    805           * @brief       This function initializes the UART.
    806           *
    807           * input parameters
    808           *
    809           * None.
    810           *
    811           * output parameters
    812           *
    813           * None.
    814           *
    815           * @return      None.
    816           **************************************************************************************************
    817           */
    818          static void halUARTInit(void)
    819          {
    820            uint16 ubr;
    821          
    822            if (halEventFlags & HAL_EVT_NO_8MHz)
    823            {
    824              ubr = (1000000UL + HOST_MT_BAUD/2) / (uint32)HOST_MT_BAUD;
    825            }
    826            else
    827            {
    828              ubr = (8000000UL + HOST_MT_BAUD/2) / (uint32)HOST_MT_BAUD;
    829            }
    830          
    831            UCA0CTL1 = UCSWRST;     // Set SWRST - UART logic held in reset state.
    832          
    833            UCA0CTL0 = 0;           // Set Frame Format: no parity; one stop-bit; 8 bits per byte.
    834          
    835            /* Set source clock & baud rate. */
    836            UCA0CTL1 |= UCSSEL1;
    837            UCA0BR1 = ubr >> 8;
    838            UCA0BR0 = ubr;
    839          
    840            P3SEL |= 0x30;  /* P3.4, 5 - UART0 TXD, RXD */
    841          
    842            UCA0CTL1 &= ~UCSWRST;  // Clear SWRST - release reset to operation.
    843            IE2 |= UCA0RXIE;       // Enable Rx ISR.
    844          }
    845          
    846          /**************************************************************************************************
    847           * @fn          halUARTRead
    848           *
    849           * @brief       This function transfers the bytes read by ISR to the parameter buffer.
    850           *
    851           * input parameters
    852           *
    853           * @param       port - HAL_PORT_NUM to read.
    854           * @param       pBuf - Pointer to the buffer to copy up to len bytes of Rx.
    855           * @param       len - Max number of bytes to copy into pBuf.
    856           *
    857           * output parameters
    858           *
    859           * @param       pBuf - Pointer to the buffer that gets filled with the Rx bytes.
    860           *
    861           * @return      Number of bytes actually copied into pBuf.
    862           **************************************************************************************************
    863           */
    864          uint8 halUARTRead(uint8 port, uint8 *pBuf, uint8 len)
    865          {
    866            uint8 cnt = 0;
    867          
    868            if (port == HAL_PORT_MT)
    869            {
    870              while (len--)
    871              {
    872                if (rx0Tail == rx0Head)
    873                {
    874                  break;
    875                }
    876          
    877                *pBuf++ = rx0Buf[rx0Tail];
    878                if (rx0Tail == 0)
    879                {
    880                  rx0Tail = ZACCEL_BUF_LEN-1;
    881                }
    882                else
    883                {
    884                  rx0Tail--;
    885                }
    886                cnt++;
    887              }
    888            }
    889          
    890            return cnt;
    891          }
    892          
    893          /**************************************************************************************************
    894           * @fn          halUARTWrite
    895           *
    896           * @brief       This function sets up the UART Tx buffer to transmit by ISR.
    897           *
    898           * input parameters
    899           *
    900           * @param       port - HAL_PORT_NUM to write.
    901           * @param       pBuf - Pointer to the buffer that contains the data to transmit.
    902           * @param       len - Length of the data to transmit.
    903           *
    904           * output parameters
    905           *
    906           * None.
    907           *
    908           * @return      None.
    909           **************************************************************************************************
    910           */
    911          void halUARTWrite(uint8 port, uint8 *pBuf, uint8 len)
    912          {
    913            if (port == HAL_PORT_MT)
    914            {
    915              while (len--)
    916              {
    917                tx0Buf[tx0Head] = *pBuf++;
    918                if (tx0Head == 0)
    919                {
    920                  tx0Head = ZACCEL_BUF_LEN-1;
    921                }
    922                else
    923                {
    924                  tx0Head--;
    925                }
    926              }
    927              IE2 |= UCA0TXIE;  // Enable UART Tx ISR.
    928            }
    929          }
    930          
    931          /**************************************************************************************************
    932           * @fn          UART ISRs
    933           *
    934           * @brief       These ISRs handle Rx/Tx on UART0.
    935           *
    936           * input parameters
    937           *
    938           * None.
    939           *
    940           * output parameters
    941           *
    942           * None.
    943           *
    944           * @return      None.
    945           **************************************************************************************************
    946           */
    947          INTERRUPT_RX0()
    948          {
    949            uint8 tmp = rx0Head;
    950          
    951            rx0Buf[tmp] = UCA0RXBUF;
    952            if (tmp == 0)
    953            {
    954              tmp = ZACCEL_BUF_LEN-1;
    955            }
    956            else
    957            {
    958              tmp--;
    959            }
    960          
    961            rx0Head = tmp;
    962            tmp = rx0Tail - tmp;
    963          #if ZACCEL_BUF_LEN != 256
    964            if (tmp > ZACCEL_BUF_LEN)
    965            {
    966              tmp += ZACCEL_BUF_LEN;
    967            }
    968          #endif
    969            if (tmp >= HOST_MT_RX_FULL-1)
    970            {
    971              halEventFlags |= HAL_EVT_MT_RX_RDY;
    972            }
    973            else
    974            {
    975              rx0Time = 1;
    976            }
    977          }
    978          
    979          INTERRUPT_TX0()
    980          {
    981            if (tx0Tail != tx0Head)
    982            {
    983              UCA0TXBUF = tx0Buf[tx0Tail];
    984              if (tx0Tail == 0)
    985              {
    986                tx0Tail = ZACCEL_BUF_LEN-1;
    987              }
    988              else
    989              {
    990                tx0Tail--;
    991              }
    992            }
    993            else
    994            {
    995              IE2 &= ~UCA0TXIE;   // Disable interrupt.
    996            }
    997          }
    998          #endif

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      2   halBoardInit
        2   -> halMcuInit
        2   -> halTimerInit
        2   -> ioInit
      8   halDelay
      2   halDelayDone
      2   halLightSensorRead
        2   -> halDelay
      4   halMcuInit
      2   halReadBusV
        2   -> halDelay
      2   halReadTemp
        2   -> halDelay
      2   halSPIWrite
      2   halSlaveReset
        2   -> halDelay
      2   halTimerInit
      4   halTimerSet
      2   ioInit
      4   isrADC
     12   isrPort1
       12   -> halDelay
      4   isrPort2
     12   isrTimerA


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      18  ??Subroutine3_0
      10  ?Subroutine0
       6  ?Subroutine1
      10  ?Subroutine2
       1  ADC10AE0
       2  ADC10CTL0
       2  ADC10CTL1
       2  ADC10MEM
       1  BCSCTL1
       1  BCSCTL3
       1  CALBC1_8MHZ
       1  CALDCO_8MHZ
       1  DCOCTL
       1  IFG2
       1  P1DIR
       1  P1IE
       1  P1IES
       1  P1IFG
       1  P1OUT
       1  P1REN
       1  P1SEL
       1  P2DIR
       1  P2IE
       1  P2IES
       1  P2IFG
       1  P2IN
       1  P2OUT
       1  P2REN
       1  P2SEL
       1  P3DIR
       1  P3OUT
       1  P3SEL
       1  P4DIR
       1  P4OUT
       1  P4SEL
       2  TACCR0
       2  TACCR0_INIT
       2  TACCTL0
       2  TACTL
       2  TAR
       2  TBCCR0
       2  TBCTL
       1  UCB0BR0
       1  UCB0BR1
       1  UCB0CTL0
       1  UCB0CTL1
       1  UCB0RXBUF
       1  UCB0TXBUF
       2  WDTCTL
       2  halAdcVal
      66  halBoardInit
      98  halDelay
      16  halDelayDone
       2  halEventFlags
      16  halLightSensorRead
     120  halMcuInit
       6  halReadBusV
      14  halReadTemp
      34  halSPIWrite
      36  halSlaveReset
      96  halTimerInit
      50  halTimerSet
     110  ioInit
      34  isrADC
       2  isrADC::??INTVEC 10
      38  isrPort1
       2  isrPort1::??INTVEC 4
      12  isrPort2
       2  isrPort2::??INTVEC 6
     106  isrTimerA
       2  isrTimerA::??INTVEC 18
       8  tmrPeriod
       8  tmrTicks

 
 896 bytes in segment CODE
  54 bytes in segment DATA16_AN
  22 bytes in segment DATA16_Z
   8 bytes in segment INTVEC
 
 896 bytes of CODE  memory
   0 bytes of CONST memory (+  8 bytes shared)
  22 bytes of DATA  memory (+ 54 bytes shared)

Errors: none
Warnings: none

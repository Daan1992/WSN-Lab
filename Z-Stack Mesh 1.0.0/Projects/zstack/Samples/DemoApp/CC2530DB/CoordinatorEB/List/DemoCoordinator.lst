###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                25/Mar/2016  20:45:55
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\Source\DemoCoordinator.c
#    Command line       =  
#        -f "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f
#        "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x02000000 -DDEFAULT_CHANLIST=0x00000800
#        -DZDAPP_CONFIG_PAN_ID=0x1AAD -DNWK_START_DELAY=100
#        -DEXTENDED_JOINING_RANDOM_MASK=0x007F -DBEACON_REQUEST_DELAY=100
#        -DBEACON_REQ_DELAY_MASK=0x00FF -DLINK_STATUS_JITTER_MASK=0x007F
#        -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED=3000
#        -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8
#        -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2
#        -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16
#        -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440 "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack
#        Mesh 1.0.0\Projects\zstack\Samples\DemoApp\Source\DemoCoordinator.c"
#        -D HOLD_AUTO_START -D BUILD_ALL_DEVICES -D REFLECTOR -D NV_INIT -D
#        xNV_RESTORE -D ZTOOL_P1 -lC
#        "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\List\"
#        -lA "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\List\"
#        --diag_suppress Pe001,Pa010,Pe1665 -o
#        "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\Obj\" -e
#        --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\" -I
#        "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\Source\" -I
#        "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Oh --require_prototypes
#    List file          =  
#        C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\List\DemoCoordinator.lst
#    Object file        =  
#        C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\Obj\DemoCoordinator.r51
#
###############################################################################

C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh 1.0.0\Projects\zstack\Samples\DemoApp\Source\DemoCoordinator.c
      1          /**************************************************************************************************
      2            Filename:       DemoCoordinator.c
      3          
      4            Description:    Coordinator application for the sensor demo utilizing Simple API.
      5          
      6                            The collector node can be set in a state where it accepts
      7                            incoming reports from the sensor nodes, and can send the reports
      8                            via the UART to a PC tool. The collector node in this state
      9                            functions as a gateway. The collector nodes that are not in the
     10                            gateway node function as routers in the network.
     11          
     12          
     13            Copyright 2009 Texas Instruments Incorporated. All rights reserved.
     14          
     15            IMPORTANT: Your use of this Software is limited to those specific rights
     16            granted under the terms of a software license agreement between the user
     17            who downloaded the software, his/her employer (which must be your employer)
     18            and Texas Instruments Incorporated (the "License").  You may not use this
     19            Software unless you agree to abide by the terms of the License. The License
     20            limits your use, and you acknowledge, that the Software may not be modified,
     21            copied or distributed unless embedded on a Texas Instruments microcontroller
     22            or used solely and exclusively in conjunction with a Texas Instruments radio
     23            frequency transceiver, which is integrated into your product.  Other than for
     24            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25            works of, modify, distribute, perform, display or sell this Software and/or
     26            its documentation for any purpose.
     27          
     28            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40            Should you have any questions regarding your right to use this Software,
     41            contact Texas Instruments Incorporated at www.TI.com.
     42          **************************************************************************************************/
     43          
     44          /******************************************************************************
     45           * INCLUDES
     46           */
     47          
     48          #include "ZComDef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Nv.h"
     51          #include "sapi.h"
     52          #include "hal_key.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     53          #include "hal_led.h"
     54          #include "hal_lcd.h"
     55          #include "hal_uart.h"
     56          #include "hal_adc.h"
     57          #include "DemoApp.h"
     58          
     59          /******************************************************************************
     60           * CONSTANTS
     61           */
     62          
     63          // General UART frame offsets
     64          #define FRAME_SOF_OFFSET                    0
     65          #define FRAME_LENGTH_OFFSET                 1
     66          #define FRAME_CMD0_OFFSET                   2
     67          #define FRAME_CMD1_OFFSET                   3
     68          #define FRAME_DATA_OFFSET                   4
     69          
     70          // Pin & port defines
     71          #define PORT                                0
     72          #define LDR_IN_ANALOG                       0
     73          #define LOCK_IN_DIGITAL                     2
     74          #define LED_OUT_DIGITAL                     4
     75          #define DOOR_OUT_DIGITAL                    7   
     76          
     77          // ZB_RECEIVE_DATA_INDICATION offsets
     78          #define ZB_RECV_SRC_OFFSET                  0
     79          #define ZB_RECV_CMD_OFFSET                  2
     80          #define ZB_RECV_LEN_OFFSET                  4
     81          #define ZB_RECV_DATA_OFFSET                 6
     82          #define ZB_RECV_FCS_OFFSET                  8
     83          
     84          // ZB_RECEIVE_DATA_INDICATION frame length
     85          #define ZB_RECV_LENGTH                      15
     86          
     87          // PING response frame length and offset
     88          #define SYS_PING_RSP_LENGTH                 7
     89          #define SYS_PING_CMD_OFFSET                 1
     90          
     91          // Stack Profile
     92          #define ZIGBEE_2007                         0x0040
     93          #define ZIGBEE_PRO_2007                     0x0041
     94          
     95          #ifdef ZIGBEEPRO
     96          #define STACK_PROFILE                       ZIGBEE_PRO_2007
     97          #else
     98          #define STACK_PROFILE                       ZIGBEE_2007
     99          #endif
    100          
    101          #define CPT_SOP                             0xFE
    102          #define SYS_PING_REQUEST                    0x0021
    103          #define SYS_PING_RESPONSE                   0x0161
    104          #define ZB_RECEIVE_DATA_INDICATION          0x8746
    105          
    106          // Application States
    107          #define APP_INIT                            0
    108          #define APP_START                           2
    109          
    110          // Application osal event identifiers
    111          #define MY_START_EVT                        0x0001
    112          #define POLL_TIMER_EVT                      0x0002
    113          
    114          /******************************************************************************
    115           * LOCAL VARIABLES
    116           */
    117          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    118          static uint8 appState =             APP_INIT;
   \                     appState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    119          static uint8 myStartRetryDelay =    10;          // milliseconds
   \                     myStartRetryDelay:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for myStartRetryDelay>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
    120          static uint8 doorOpen =             0xFF;
   \                     doorOpen:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for doorOpen>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
    121          static uint8 lampTriggered =        0xFF;
   \                     lampTriggered:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for lampTriggered>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
    122          static uint8 lastLockState =        0xFF;
   \                     lastLockState:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for lastLockState>`
   \   000001                REQUIRE __INIT_XDATA_I
    123          
    124          /******************************************************************************
    125           * LOCAL FUNCTIONS
    126           */
    127          
    128          static uint8 calcFCS(uint8 *pBuf, uint8 len);
    129          static void sysPingReqRcvd(void);
    130          static void sysPingRsp(void);
    131          
    132          /******************************************************************************
    133           * GLOBAL VARIABLES
    134           */
    135          
    136          // Inputs and Outputs for Collector device
    137          #define NUM_OUT_CMD_COLLECTOR           1
    138          #define NUM_IN_CMD_COLLECTOR            1
    139          
    140          // List of output and input commands for Collector device

   \                                 In  segment XDATA_ROM_C, align 1
    141          const cId_t zb_OutCmdList[NUM_OUT_CMD_COLLECTOR] =
   \                     zb_OutCmdList:
   \   000000   0400         DW 4
    142          {
    143            COORD_REPORT_CMD_ID,
    144          };

   \                                 In  segment XDATA_ROM_C, align 1
    145          const cId_t zb_InCmdList[NUM_IN_CMD_COLLECTOR] =
   \                     zb_InCmdList:
   \   000000   0300         DW 3
    146          {
    147            ROUTER_REPORT_CMD_ID,
    148          };
    149          
    150          // Define SimpleDescriptor for Collector device

   \                                 In  segment XDATA_ROM_C, align 1
    151          const SimpleDescriptionFormat_t zb_SimpleDesc =
   \                     zb_SimpleDesc:
   \   000000   02           DB 2
   \   000001   200F         DW 3872
   \   000003   0200         DW 2
   \   000005   01           DB 1
   \   000006   01           DB 1
   \   000007   ....         DW zb_InCmdList
   \   000009   01           DB 1
   \   00000A   0000         DW 0H
    152          {
    153            MY_ENDPOINT_ID,             //  Endpoint
    154            MY_PROFILE_ID,              //  Profile ID
    155            DEV_ID_COORDINATOR,         //  Device ID
    156            DEVICE_VERSION_COLLECTOR,   //  Device Version
    157            0,                          //  Reserved
    158            NUM_IN_CMD_COLLECTOR,       //  Number of Input Commands
    159            (cId_t *) zb_InCmdList,     //  Input Command List
    160            NUM_OUT_CMD_COLLECTOR,      //  Number of Output Commands
    161            (cId_t *) NULL              //  Output Command List
    162          };
    163          
    164          /******************************************************************************
    165           * FUNCTIONS
    166           */
    167          
    168          /******************************************************************************
    169           * @fn          zb_HandleOsalEvent
    170           *
    171           * @brief       The zb_HandleOsalEvent function is called by the operating
    172           *              system when a task event is set
    173           *
    174           * @param       event - Bitmask containing the events that have been set
    175           *
    176           * @return      none
    177           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    178          void zb_HandleOsalEvent( uint16 event )
   \                     zb_HandleOsalEvent:
    179          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
    180            if( event & SYS_EVENT_MSG )
    181            {
    182            }
    183          
    184            if( event & ZB_ENTRY_EVENT )
   \   00000D   5410         ANL     A,#0x10
   \   00000F   6047         JZ      ??zb_HandleOsalEvent_0
    185            {
    186              // Initialise UART
    187              initUart(uartRxCB);
   \   000011                ; Setup parameters for call to function initUart
   \   000011   7A..         MOV     R2,#`??uartRxCB::?relay` & 0xff
   \   000013   7B..         MOV     R3,#(`??uartRxCB::?relay` >> 8) & 0xff
   \   000015   12....       LCALL   `??initUart::?relay` ; Banked call to: initUart
    188          
    189              // blind LED 1 to indicate starting/joining a network
    190              HalLedBlink ( HAL_LED_1, 0, 50, 500 );
   \   000018                ; Setup parameters for call to function HalLedBlink
   \   000018   7CF4         MOV     R4,#-0xc
   \   00001A   7D01         MOV     R5,#0x1
   \   00001C   7B32         MOV     R3,#0x32
   \   00001E   7A00         MOV     R2,#0x0
   \   000020   7901         MOV     R1,#0x1
   \   000022   12....       LCALL   `??HalLedBlink::?relay`; Banked call to: HalLedBlink
    191              HalLedSet( HAL_LED_2, HAL_LED_MODE_OFF );
   \   000025                ; Setup parameters for call to function HalLedSet
   \   000025   7A00         MOV     R2,#0x0
   \   000027   7902         MOV     R1,#0x2
   \   000029   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    192          
    193              //Initiate ADC
    194              HalAdcInit();
   \   00002C                ; Setup parameters for call to function HalAdcInit
   \   00002C   12....       LCALL   `??HalAdcInit::?relay`; Banked call to: HalAdcInit
    195                
    196              //Initiate GPIO
    197              MCU_IO_DIR_OUTPUT(PORT, LED_OUT_DIGITAL);
   \   00002F   43FD10       ORL     0xfd,#0x10
    198              MCU_IO_DIR_OUTPUT(PORT, DOOR_OUT_DIGITAL);
   \   000032   43FD80       ORL     0xfd,#0x80
    199              MCU_IO_INPUT(PORT, LOCK_IN_DIGITAL, MCU_IO_PULLDOWN);
   \   000035   53F3FB       ANL     0xf3,#0xfb
   \   000038   53FDFB       ANL     0xfd,#0xfb
   \   00003B   538FFB       ANL     0x8f,#0xfb
   \   00003E   43F720       ORL     0xf7,#0x20
    200              
    201              // Start the device
    202              zb_StartRequest();
   \   000041                ; Setup parameters for call to function zb_StartRequest
   \   000041   12....       LCALL   `??zb_StartRequest::?relay`; Banked call to: zb_StartRequest
    203              osal_start_reload_timer( 0xFA, POLL_TIMER_EVT, 500); 
   \   000044                ; Setup parameters for call to function osal_start_reload_timer
   \   000044   90....       MOV     DPTR,#__Constant_1f4
   \   000047   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   00004A   7A02         MOV     R2,#0x2
   \   00004C   7B00         MOV     R3,#0x0
   \   00004E   79FA         MOV     R1,#-0x6
   \   000050   12....       LCALL   `??osal_start_reload_timer::?relay`; Banked call to: osal_start_reload_timer
   \   000053   7404         MOV     A,#0x4
   \   000055   12....       LCALL   ?DEALLOC_XSTACK8
    204            }
    205          
    206            if ( event & MY_START_EVT )
   \                     ??zb_HandleOsalEvent_0:
   \   000058   EE           MOV     A,R6
   \   000059   A2E0         MOV     C,0xE0 /* A   */.0
   \   00005B   5003         JNC     ??zb_HandleOsalEvent_1
    207            {
    208              zb_StartRequest();
   \   00005D                ; Setup parameters for call to function zb_StartRequest
   \   00005D   12....       LCALL   `??zb_StartRequest::?relay`; Banked call to: zb_StartRequest
    209            }
    210            if ( event & POLL_TIMER_EVT )
   \                     ??zb_HandleOsalEvent_1:
   \   000060   EE           MOV     A,R6
   \   000061   5402         ANL     A,#0x2
   \   000063   6075         JZ      ??zb_HandleOsalEvent_2
    211            {
    212              if (HalAdcRead(HAL_ADC_CHN_AIN0, HAL_ADC_RESOLUTION_8) > 0xFF00) 
   \   000065                ; Setup parameters for call to function HalAdcRead
   \   000065   7A01         MOV     R2,#0x1
   \   000067   7900         MOV     R1,#0x0
   \   000069   12....       LCALL   `??HalAdcRead::?relay`; Banked call to: HalAdcRead
   \   00006C   C3           CLR     C
   \   00006D   EA           MOV     A,R2
   \   00006E   9401         SUBB    A,#0x1
   \   000070   EB           MOV     A,R3
   \   000071   94FF         SUBB    A,#-0x1
   \   000073   400B         JC      ??zb_HandleOsalEvent_3
    213              {  
    214                MCU_IO_SET(PORT, LED_OUT_DIGITAL, lampTriggered);
   \   000075   90....       MOV     DPTR,#lampTriggered
   \   000078   E0           MOVX    A,@DPTR
   \   000079   F8           MOV     R0,A
   \   00007A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00007C   9284         MOV     0x80.4,C
   \   00007E   8002         SJMP    ??zb_HandleOsalEvent_4
    215              }
    216              else 
    217              {
    218                MCU_IO_SET_LOW(PORT, LED_OUT_DIGITAL);
   \                     ??zb_HandleOsalEvent_3:
   \   000080   C284         CLR     0x80.4
    219              }
    220              if (MCU_IO_GET(PORT, LOCK_IN_DIGITAL) != lastLockState)
   \                     ??zb_HandleOsalEvent_4:
   \   000082   E580         MOV     A,0x80
   \   000084   5404         ANL     A,#0x4
   \   000086   F8           MOV     R0,A
   \   000087   90....       MOV     DPTR,#lastLockState
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   68           XRL     A,R0
   \   00008C   604C         JZ      ??zb_HandleOsalEvent_2
    221              {
    222                lastLockState = MCU_IO_GET(PORT, LOCK_IN_DIGITAL);
   \   00008E   E580         MOV     A,0x80
   \   000090   5404         ANL     A,#0x4
   \   000092   F0           MOVX    @DPTR,A
    223                uint8 pData[1];
    224                static uint8 reportNr = 0;
    225                uint8 txOptions;
    226                
    227                if (lastLockState) 
   \   000093   85..82       MOV     DPL,?XSP + 0
   \   000096   85..83       MOV     DPH,?XSP + 1
   \   000099   6004         JZ      ??zb_HandleOsalEvent_5
    228                {
    229                  pData[0] = DOOR_UNLOCKED;
   \   00009B   74F3         MOV     A,#-0xd
   \   00009D   8002         SJMP    ??zb_HandleOsalEvent_6
    230                }
    231                else
    232                {
    233                  pData[0] = DOOR_LOCKED;
   \                     ??zb_HandleOsalEvent_5:
   \   00009F   74F2         MOV     A,#-0xe
   \                     ??zb_HandleOsalEvent_6:
   \   0000A1   F0           MOVX    @DPTR,A
    234                }
    235                zb_SendDataRequest( 0xFFFF, COORD_REPORT_CMD_ID, 1, pData, 0, txOptions, 0 );
                                                                                     ^
Warning[Pe549]: variable "txOptions" is used before its value is set

        static uint8 reportNr = 0;
                     ^
"C:\Users\DLeijen\Documents\WSN-Lab\Z-Stack Mesh 1.0.0\Projects\zstack\Samples\DemoApp\Source\DemoCoordinator.c",224  Warning[Pe177]: 
          variable "reportNr" was declared but never referenced
   \   0000A2                ; Setup parameters for call to function zb_SendDataRequest
   \   0000A2   75..00       MOV     ?V0,#0x0
   \   0000A5   78..         MOV     R0,#?V0
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AA   E9           MOV     A,R1
   \   0000AB   F5..         MOV     ?V0,A
   \   0000AD   78..         MOV     R0,#?V0
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B2   75..00       MOV     ?V0,#0x0
   \   0000B5   78..         MOV     R0,#?V0
   \   0000B7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BA   7403         MOV     A,#0x3
   \   0000BC   12....       LCALL   ?XSTACK_DISP100_8
   \   0000BF   88..         MOV     ?V0,R0
   \   0000C1   89..         MOV     ?V1,R1
   \   0000C3   78..         MOV     R0,#?V0
   \   0000C5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C8   7901         MOV     R1,#0x1
   \   0000CA   7C04         MOV     R4,#0x4
   \   0000CC   7D00         MOV     R5,#0x0
   \   0000CE   7AFF         MOV     R2,#-0x1
   \   0000D0   7BFF         MOV     R3,#-0x1
   \   0000D2   12....       LCALL   `??zb_SendDataRequest::?relay`; Banked call to: zb_SendDataRequest
   \   0000D5   7405         MOV     A,#0x5
   \   0000D7   12....       LCALL   ?DEALLOC_XSTACK8
    236              }
    237            }
    238          }
   \                     ??zb_HandleOsalEvent_2:
   \   0000DA   7401         MOV     A,#0x1
   \   0000DC                REQUIRE ?Subroutine0
   \   0000DC                REQUIRE P0DIR
   \   0000DC                REQUIRE P0SEL
   \   0000DC                REQUIRE P0INP
   \   0000DC                REQUIRE P2INP
   \   0000DC                REQUIRE _A_P0
   \   0000DC                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F02         MOV     R7,#0x2
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
    239          
    240          /******************************************************************************
    241           * @fn      zb_HandleKeys
    242           *
    243           * @brief   Handles all key events for this device.
    244           *
    245           * @param   shift - true if in shift/alt.
    246           * @param   keys - bit field for key events. Valid entries:
    247           *                 EVAL_SW4
    248           *                 EVAL_SW3
    249           *                 EVAL_SW2
    250           *                 EVAL_SW1
    251           *
    252           * @return  none
    253           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    254          void zb_HandleKeys( uint8 shift, uint8 keys )
   \                     zb_HandleKeys:
    255          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FF           MOV     R7,A
    256            static uint8 allowBind = FALSE;
    257          
    258            // Shift is used to make each button/switch dual purpose.
    259            if ( shift )
   \   000009   EE           MOV     A,R6
   \   00000A   702B         JNZ     ??zb_HandleKeys_0
    260            {
    261              if ( keys & HAL_KEY_SW_1 )
    262              {
    263              }
    264              if ( keys & HAL_KEY_SW_2 )
    265              {
    266              }
    267              if ( keys & HAL_KEY_SW_3 )
    268              {
    269              }
    270              if ( keys & HAL_KEY_SW_4 )
    271              {
    272              }
    273            }
    274            else
    275            {
    276              if ( keys & HAL_KEY_SW_1 )
   \   00000C   EF           MOV     A,R7
   \   00000D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000F   5026         JNC     ??zb_HandleKeys_0
    277              {
    278                if ( appState == APP_START )
   \   000011   90....       MOV     DPTR,#appState
   \   000014   E0           MOVX    A,@DPTR
   \   000015   6402         XRL     A,#0x2
   \   000017   701E         JNZ     ??zb_HandleKeys_0
    279                {
    280                  allowBind ^= 1;
   \   000019   90....       MOV     DPTR,#??allowBind
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   6401         XRL     A,#0x1
   \   00001F   F0           MOVX    @DPTR,A
    281                  if ( allowBind )
   \   000020   6009         JZ      ??zb_HandleKeys_1
    282                  {
    283                    // Turn ON Allow Bind mode infinitly
    284                    zb_AllowBind( 0xFF );
   \   000022                ; Setup parameters for call to function zb_AllowBind
   \   000022   79FF         MOV     R1,#-0x1
   \   000024   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    285                    HalLedSet( HAL_LED_2, HAL_LED_MODE_ON );
   \   000027                ; Setup parameters for call to function HalLedSet
   \   000027   7A01         MOV     R2,#0x1
   \   000029   8007         SJMP    ??zb_HandleKeys_2
    286                  }
    287                  else
    288                  {
    289                    // Turn OFF Allow Bind mode infinitly
    290                    zb_AllowBind( 0x00 );
   \                     ??zb_HandleKeys_1:
   \   00002B                ; Setup parameters for call to function zb_AllowBind
   \   00002B   7900         MOV     R1,#0x0
   \   00002D   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    291                    HalLedSet( HAL_LED_2, HAL_LED_MODE_OFF );
   \   000030                ; Setup parameters for call to function HalLedSet
   \   000030   7A00         MOV     R2,#0x0
   \                     ??zb_HandleKeys_2:
   \   000032   7902         MOV     R1,#0x2
   \   000034   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    292                  }
    293                }
    294              }
    295              if ( keys & HAL_KEY_SW_2 )
    296              {
    297              }
    298              if ( keys & HAL_KEY_SW_3 )
    299              {
    300              }
    301              if ( keys & HAL_KEY_SW_4 )
    302              {
    303              }
    304            }
    305          }
   \                     ??zb_HandleKeys_0:
   \   000037   7F01         MOV     R7,#0x1
   \   000039   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??allowBind:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    306          
    307          /******************************************************************************
    308           * @fn          zb_StartConfirm
    309           *
    310           * @brief       The zb_StartConfirm callback is called by the ZigBee stack
    311           *              after a start request operation completes
    312           *
    313           * @param       status - The status of the start operation.  Status of
    314           *                       ZB_SUCCESS indicates the start operation completed
    315           *                       successfully.  Else the status is an error code.
    316           *
    317           * @return      none
    318           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    319          void zb_StartConfirm( uint8 status )
   \                     zb_StartConfirm:
    320          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    321            // If the device sucessfully started, change state to running
    322            if ( status == ZB_SUCCESS )
   \   000006   700F         JNZ     ??zb_StartConfirm_0
    323            {
    324              // Set LED 1 to indicate that node is operational on the network
    325              HalLedSet( HAL_LED_1, HAL_LED_MODE_ON );
   \   000008                ; Setup parameters for call to function HalLedSet
   \   000008   7A01         MOV     R2,#0x1
   \   00000A   7901         MOV     R1,#0x1
   \   00000C   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    326          
    327              // Change application state
    328              appState = APP_START;
   \   00000F   90....       MOV     DPTR,#appState
   \   000012   7402         MOV     A,#0x2
   \   000014   F0           MOVX    @DPTR,A
   \   000015   8023         SJMP    ??zb_StartConfirm_1
    329            }
    330            else
    331            {
    332              // Try again later with a delay
    333              osal_start_timerEx( sapi_TaskID, MY_START_EVT, myStartRetryDelay );
   \                     ??zb_StartConfirm_0:
   \   000017                ; Setup parameters for call to function osal_start_timerEx
   \   000017   90....       MOV     DPTR,#myStartRetryDelay
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F5..         MOV     ?V0,A
   \   00001D   E4           CLR     A
   \   00001E   F5..         MOV     ?V1,A
   \   000020   F5..         MOV     ?V2,A
   \   000022   F5..         MOV     ?V3,A
   \   000024   78..         MOV     R0,#?V0
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000029   7A01         MOV     R2,#0x1
   \   00002B   7B00         MOV     R3,#0x0
   \   00002D   90....       MOV     DPTR,#sapi_TaskID
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000035   7404         MOV     A,#0x4
   \   000037   12....       LCALL   ?DEALLOC_XSTACK8
    334            }
    335          }
   \                     ??zb_StartConfirm_1:
   \   00003A   7F04         MOV     R7,#0x4
   \   00003C   02....       LJMP    ?BANKED_LEAVE_XDATA
    336          
    337          /******************************************************************************
    338           * @fn          zb_SendDataConfirm
    339           *
    340           * @brief       The zb_SendDataConfirm callback function is called by the
    341           *              ZigBee stack after a send data operation completes
    342           *
    343           * @param       handle - The handle identifying the data transmission.
    344           *              status - The status of the operation.
    345           *
    346           * @return      none
    347           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    348          void zb_SendDataConfirm( uint8 handle, uint8 status )
   \                     zb_SendDataConfirm:
    349          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    350            (void)handle;
    351            (void)status;
    352          }
   \   000000   02....       LJMP    ?BRET
    353          
    354          /******************************************************************************
    355           * @fn          zb_BindConfirm
    356           *
    357           * @brief       The zb_BindConfirm callback is called by the ZigBee stack
    358           *              after a bind operation completes.
    359           *
    360           * @param       commandId - The command ID of the binding being confirmed.
    361           *              status - The status of the bind operation.
    362           *
    363           * @return      none
    364           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    365          void zb_BindConfirm( uint16 commandId, uint8 status )
   \                     zb_BindConfirm:
    366          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    367            (void)commandId;
    368            (void)status;
    369          }
   \   000000   02....       LJMP    ?BRET
    370          
    371          /******************************************************************************
    372           * @fn          zb_AllowBindConfirm
    373           *
    374           * @brief       Indicates when another device attempted to bind to this device
    375           *
    376           * @param
    377           *
    378           * @return      none
    379           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    380          void zb_AllowBindConfirm( uint16 source )
   \                     zb_AllowBindConfirm:
    381          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    382            (void)source;
    383          }
   \   000000   02....       LJMP    ?BRET
    384          
    385          /******************************************************************************
    386           * @fn          zb_FindDeviceConfirm
    387           *
    388           * @brief       The zb_FindDeviceConfirm callback function is called by the
    389           *              ZigBee stack when a find device operation completes.
    390           *
    391           * @param       searchType - The type of search that was performed.
    392           *              searchKey - Value that the search was executed on.
    393           *              result - The result of the search.
    394           *
    395           * @return      none
    396           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    397          void zb_FindDeviceConfirm( uint8 searchType, uint8 *searchKey, uint8 *result )
   \                     zb_FindDeviceConfirm:
    398          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    399            (void)searchType;
    400            (void)searchKey;
    401            (void)result;
    402          }
   \   000000   02....       LJMP    ?BRET
    403          
    404          /******************************************************************************
    405           * @fn          zb_ReceiveDataIndication
    406           *
    407           * @brief       The zb_ReceiveDataIndication callback function is called
    408           *              asynchronously by the ZigBee stack to notify the application
    409           *              when data is received from a peer device.
    410           *
    411           * @param       source - The short address of the peer device that sent the data
    412           *              command - The commandId associated with the data
    413           *              len - The number of bytes in the pData parameter
    414           *              pData - The data sent by the peer device
    415           *
    416           * @return      none
    417           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    418          void zb_ReceiveDataIndication( uint16 source, uint16 command, uint16 len, uint8 *pData  )
   \                     zb_ReceiveDataIndication:
    419          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   85..82       MOV     DPL,?XSP + 0
   \   000007   85..83       MOV     DPH,?XSP + 1
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FA           MOV     R2,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   FB           MOV     R3,A
   \   00000F   7402         MOV     A,#0x2
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   E8           MOV     A,R0
   \   00001A   2A           ADD     A,R2
   \   00001B   F8           MOV     R0,A
   \   00001C   E9           MOV     A,R1
   \   00001D   3B           ADDC    A,R3
   \   00001E   F9           MOV     R1,A
   \   00001F   E8           MOV     A,R0
   \   000020   24FF         ADD     A,#-0x1
   \   000022   F582         MOV     DPL,A
   \   000024   E9           MOV     A,R1
   \   000025   34FF         ADDC    A,#-0x1
   \   000027   F583         MOV     DPH,A
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F8           MOV     R0,A
   \   00002B   74F0         MOV     A,#-0x10
   \   00002D   68           XRL     A,R0
   \   00002E   7019         JNZ     ??zb_ReceiveDataIndication_0
    420            if (pData[len-1] == DOOR_BUTTON_PRESSED) 
    421            {
    422              doorOpen = !doorOpen;
   \   000030   90....       MOV     DPTR,#doorOpen
   \   000033   E0           MOVX    A,@DPTR
   \   000034   7004         JNZ     ??zb_ReceiveDataIndication_1
   \   000036   7401         MOV     A,#0x1
   \   000038   8002         SJMP    ??zb_ReceiveDataIndication_2
   \                     ??zb_ReceiveDataIndication_1:
   \   00003A   7400         MOV     A,#0x0
   \                     ??zb_ReceiveDataIndication_2:
   \   00003C   F0           MOVX    @DPTR,A
    423              if (doorOpen) {
   \   00003D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00003F   5004         JNC     ??zb_ReceiveDataIndication_3
    424                MCU_IO_SET_HIGH(PORT, DOOR_OUT_DIGITAL);
   \   000041   D287         SETB    0x80.7
   \   000043   8016         SJMP    ??zb_ReceiveDataIndication_4
    425              }
    426              else
    427              {
    428                MCU_IO_SET_LOW(PORT, DOOR_OUT_DIGITAL);
   \                     ??zb_ReceiveDataIndication_3:
   \   000045   C287         CLR     0x80.7
   \   000047   8012         SJMP    ??zb_ReceiveDataIndication_4
    429              }
    430            }
    431            else if (pData[len-1] == LAMP_BUTTON_PRESSED)
   \                     ??zb_ReceiveDataIndication_0:
   \   000049   74F1         MOV     A,#-0xf
   \   00004B   68           XRL     A,R0
   \   00004C   700D         JNZ     ??zb_ReceiveDataIndication_4
    432            {
    433              lampTriggered = !lampTriggered;
   \   00004E   90....       MOV     DPTR,#lampTriggered
   \   000051   E0           MOVX    A,@DPTR
   \   000052   7004         JNZ     ??zb_ReceiveDataIndication_5
   \   000054   7401         MOV     A,#0x1
   \   000056   8002         SJMP    ??zb_ReceiveDataIndication_6
   \                     ??zb_ReceiveDataIndication_5:
   \   000058   7400         MOV     A,#0x0
   \                     ??zb_ReceiveDataIndication_6:
   \   00005A   F0           MOVX    @DPTR,A
    434            }
    435          }
   \                     ??zb_ReceiveDataIndication_4:
   \   00005B   D083         POP     DPH
   \   00005D   D082         POP     DPL
   \   00005F   02....       LJMP    ?BRET
   \   000062                REQUIRE _A_P0
    436          
    437          /******************************************************************************
    438           * @fn          uartRxCB
    439           *
    440           * @brief       Callback function for UART
    441           *
    442           * @param       port - UART port
    443           *              event - UART event that caused callback
    444           *
    445           * @return      none
    446           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    447          void uartRxCB( uint8 port, uint8 event )
   \                     uartRxCB:
    448          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 135
   \   000005   7479         MOV     A,#0x79
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
    449            (void)port;
    450          
    451            uint8 pBuf[RX_BUF_LEN];
    452            uint16 cmd;
    453            uint16 len;
    454          
    455            if ( event != HAL_UART_TX_EMPTY )
   \   00000C   7410         MOV     A,#0x10
   \   00000E   6E           XRL     A,R6
   \   00000F   7003         JNZ     $+5
   \   000011   02....       LJMP    ??uartRxCB_0 & 0xFFFF
    456            {
    457              // Read from UART
    458              len = HalUARTRead( HAL_UART_PORT_0, pBuf, RX_BUF_LEN );
    459          
    460              if ( len > 0 )
   \   000014                ; Setup parameters for call to function HalUARTRead
   \   000014   7C80         MOV     R4,#-0x80
   \   000016   7D00         MOV     R5,#0x0
   \   000018   7407         MOV     A,#0x7
   \   00001A   12....       LCALL   ?XSTACK_DISP101_8
   \   00001D   7900         MOV     R1,#0x0
   \   00001F   12....       LCALL   `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   000022   8B..         MOV     ?V1,R3
   \   000024   EA           MOV     A,R2
   \   000025   45..         ORL     A,?V1
   \   000027   6071         JZ      ??uartRxCB_0
    461              {
    462                cmd = BUILD_UINT16(pBuf[SYS_PING_CMD_OFFSET + 1], pBuf[SYS_PING_CMD_OFFSET]);
    463          
    464                if( (pBuf[FRAME_SOF_OFFSET] == CPT_SOP) && (cmd == SYS_PING_REQUEST) )
   \   000029   7407         MOV     A,#0x7
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   64FE         XRL     A,#0xfe
   \   000031   7067         JNZ     ??uartRxCB_0
   \   000033   7409         MOV     A,#0x9
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FA           MOV     R2,A
   \   00003A   7408         MOV     A,#0x8
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   EA           MOV     A,R2
   \   000042   F8           MOV     R0,A
   \   000043   7421         MOV     A,#0x21
   \   000045   68           XRL     A,R0
   \   000046   49           ORL     A,R1
   \   000047   7051         JNZ     ??uartRxCB_0
    465                {
    466                  sysPingReqRcvd();
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   74FE         MOV     A,#-0x2
   \   000051   F0           MOVX    @DPTR,A
   \   000052   7401         MOV     A,#0x1
   \   000054   12....       LCALL   ?XSTACK_DISP0_8
   \   000057   7402         MOV     A,#0x2
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   7461         MOV     A,#0x61
   \   00005F   F0           MOVX    @DPTR,A
   \   000060   7403         MOV     A,#0x3
   \   000062   12....       LCALL   ?XSTACK_DISP0_8
   \   000065   7401         MOV     A,#0x1
   \   000067   F0           MOVX    @DPTR,A
   \   000068   7404         MOV     A,#0x4
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   7441         MOV     A,#0x41
   \   00006F   F0           MOVX    @DPTR,A
   \   000070   7405         MOV     A,#0x5
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   E4           CLR     A
   \   000076   F0           MOVX    @DPTR,A
   \   000077   04           INC     A
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   7800         MOV     R0,#0x0
   \   00007D   7905         MOV     R1,#0x5
   \                     ??uartRxCB_1:
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   C8           XCH     A,R0
   \   000081   68           XRL     A,R0
   \   000082   F8           MOV     R0,A
   \   000083   A3           INC     DPTR
   \   000084   D9F9         DJNZ    R1,??uartRxCB_1
   \   000086   7406         MOV     A,#0x6
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   E8           MOV     A,R0
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D                ; Setup parameters for call to function HalUARTWrite
   \   00008D   7C07         MOV     R4,#0x7
   \   00008F   7D00         MOV     R5,#0x0
   \   000091   AA..         MOV     R2,?XSP + 0
   \   000093   AB..         MOV     R3,?XSP + 1
   \   000095   7900         MOV     R1,#0x0
   \   000097   12....       LCALL   `??HalUARTWrite::?relay`; Banked call to: HalUARTWrite
    467                }
    468              }
    469            }
    470          }
   \                     ??uartRxCB_0:
   \   00009A   7487         MOV     A,#-0x79
   \   00009C   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for myStartRetryDelay>`:
   \   000000   0A           DB 10

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for doorOpen>`:
   \   000000   FF           DB 255

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for lampTriggered>`:
   \   000000   FF           DB 255

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for lastLockState>`:
   \   000000   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1f4:
   \   000000   F4010000     DD 500

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_HandleOsalEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_HandleOsalEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_HandleKeys::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_HandleKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_StartConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_StartConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_SendDataConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_SendDataConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_BindConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_BindConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_AllowBindConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_AllowBindConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_FindDeviceConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_FindDeviceConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_ReceiveDataIndication::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_ReceiveDataIndication

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??uartRxCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uartRxCB
    471          
    472          /******************************************************************************
    473           * @fn          sysPingReqRcvd
    474           *
    475           * @brief       Ping request received
    476           *
    477           * @param       none
    478           *
    479           * @return      none
    480           */
    481          static void sysPingReqRcvd(void)
    482          {
    483             sysPingRsp();
    484          }
    485          
    486          /******************************************************************************
    487           * @fn          sysPingRsp
    488           *
    489           * @brief       Build and send Ping response
    490           *
    491           * @param       none
    492           *
    493           * @return      none
    494           */
    495          static void sysPingRsp(void)
    496          {
    497            uint8 pBuf[SYS_PING_RSP_LENGTH];
    498          
    499            // Start of Frame Delimiter
    500            pBuf[FRAME_SOF_OFFSET] = CPT_SOP;
    501          
    502            // Length
    503            pBuf[FRAME_LENGTH_OFFSET] = 2;
    504          
    505            // Command type
    506            pBuf[FRAME_CMD0_OFFSET] = LO_UINT16(SYS_PING_RESPONSE);
    507            pBuf[FRAME_CMD1_OFFSET] = HI_UINT16(SYS_PING_RESPONSE);
    508          
    509            // Stack profile
    510            pBuf[FRAME_DATA_OFFSET] = LO_UINT16(STACK_PROFILE);
    511            pBuf[FRAME_DATA_OFFSET + 1] = HI_UINT16(STACK_PROFILE);
    512          
    513            // Frame Check Sequence
    514            pBuf[SYS_PING_RSP_LENGTH - 1] = calcFCS(&pBuf[FRAME_LENGTH_OFFSET], (SYS_PING_RSP_LENGTH - 2));
    515          
    516            // Write frame to UART
    517            HalUARTWrite(HAL_UART_PORT_0,pBuf, SYS_PING_RSP_LENGTH);
    518          }
    519          
    520          /******************************************************************************
    521           * @fn          calcFCS
    522           *
    523           * @brief       This function calculates the FCS checksum for the serial message
    524           *
    525           * @param       pBuf - Pointer to the end of a buffer to calculate the FCS.
    526           *              len - Length of the pBuf.
    527           *
    528           * @return      The calculated FCS.
    529           ******************************************************************************
    530           */
    531          static uint8 calcFCS(uint8 *pBuf, uint8 len)
    532          {
    533            uint8 rtrn = 0;
    534          
    535            while ( len-- )
    536            {
    537              rtrn ^= *pBuf++;
    538            }
    539          
    540            return rtrn;
    541          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1    145   uartRxCB
        0    145   -> HalUARTRead
        0    145   -> HalUARTWrite
      0      0   zb_AllowBindConfirm
      0      0   zb_BindConfirm
      0      0   zb_FindDeviceConfirm
      0      9   zb_HandleKeys
        0      9   -> HalLedSet
        0      9   -> zb_AllowBind
      0     16   zb_HandleOsalEvent
        0     11   -> HalAdcInit
        0     11   -> HalAdcRead
        0     11   -> HalLedBlink
        0     11   -> HalLedSet
        0     11   -> initUart
        0     15   -> osal_start_reload_timer
        0     16   -> zb_SendDataRequest
        0     11   -> zb_StartRequest
      2      4   zb_ReceiveDataIndication
      0      0   zb_SendDataConfirm
      0     16   zb_StartConfirm
        0     12   -> HalLedSet
        0     16   -> osal_start_timerEx


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for doorOpen>
       1  ?<Initializer for lampTriggered>
       1  ?<Initializer for lastLockState>
       1  ?<Initializer for myStartRetryDelay>
       8  ?Subroutine0
       1  P0DIR
       1  P0INP
       1  P0SEL
       1  P2INP
       1  _A_P0
       4  __Constant_1f4
       1  allowBind
       1  appState
       1  doorOpen
       1  lampTriggered
       1  lastLockState
       1  myStartRetryDelay
     159  uartRxCB
       6  uartRxCB::?relay
       3  zb_AllowBindConfirm
       6  zb_AllowBindConfirm::?relay
       3  zb_BindConfirm
       6  zb_BindConfirm::?relay
       3  zb_FindDeviceConfirm
       6  zb_FindDeviceConfirm::?relay
      60  zb_HandleKeys
       6  zb_HandleKeys::?relay
     220  zb_HandleOsalEvent
       6  zb_HandleOsalEvent::?relay
       2  zb_InCmdList
       2  zb_OutCmdList
      98  zb_ReceiveDataIndication
       6  zb_ReceiveDataIndication::?relay
       3  zb_SendDataConfirm
       6  zb_SendDataConfirm::?relay
      12  zb_SimpleDesc
      63  zb_StartConfirm
       6  zb_StartConfirm::?relay

 
 620 bytes in segment BANKED_CODE
  54 bytes in segment BANK_RELAYS
   5 bytes in segment SFR_AN
   4 bytes in segment XDATA_I
   4 bytes in segment XDATA_ID
  20 bytes in segment XDATA_ROM_C
   2 bytes in segment XDATA_Z
 
 678 bytes of CODE  memory
  16 bytes of CONST memory (+ 4 bytes shared)
   0 bytes of DATA  memory (+ 5 bytes shared)
   6 bytes of XDATA memory

Errors: none
Warnings: 2
